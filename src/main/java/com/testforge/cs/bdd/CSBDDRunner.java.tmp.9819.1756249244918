package com.testforge.cs.bdd;

import com.testforge.cs.analysis.CSFailureAnalyzer;
import com.testforge.cs.config.CSConfigManager;
import com.testforge.cs.core.CSBaseTest;
import com.testforge.cs.driver.CSWebDriverManager;
import org.openqa.selenium.WebDriver;
import com.testforge.cs.driver.CSDriver;
import com.testforge.cs.reporting.CSReportManager;
import com.testforge.cs.reporting.CSTestResult;
import com.testforge.cs.screenshot.CSScreenshotUtils;
import com.testforge.cs.azuredevops.CSAzureDevOpsPublisher;
import com.testforge.cs.azuredevops.extractors.CSADOTagExtractor;
import com.testforge.cs.azuredevops.managers.CSTestRunManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.ITestContext;
import org.testng.ITestResult;
import org.testng.annotations.AfterClass;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Parameters;
import org.testng.annotations.Test;

import java.io.File;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Framework-provided BDD Runner for executing Gherkin feature files
 * Can be configured via TestNG XML suite files
 */
public class CSBDDRunner extends CSBaseTest {
    
    private static final Logger logger = LoggerFactory.getLogger(CSBDDRunner.class);
    
    private String featuresPath;
    private String tagsToRun;
    private String tagsToExclude;
    private String stepDefPackages;
    private List<String> featureFiles = new ArrayList<>();
    private CSFeatureParser featureParser;
    private CSScenarioRunner scenarioRunner;
    
    // Azure DevOps integration (optional - activated when ADO is enabled)
    private CSAzureDevOpsPublisher adoPublisher;
    private boolean adoTestRunStarted = false; // Track if we've started an ADO test run
    private String suiteAdoEnabled; // Track suite parameter for ado.enabled
    private Set<Integer> adoTestPointIds = new HashSet<>(); // Collect test point IDs for the test run
    
    // Suite XML parameters for ADO (highest priority)
    private String suiteXmlTestPlanId;
    private String suiteXmlTestSuiteId;
    private static final Pattern TEST_CASE_PATTERN = Pattern.compile("@TestCaseId[-:](\\d+)", Pattern.CASE_INSENSITIVE);
    private static final Pattern TEST_PLAN_PATTERN = Pattern.compile("@TestPlanId[-:](\\d+)", Pattern.CASE_INSENSITIVE);
    private static final Pattern TEST_SUITE_PATTERN = Pattern.compile("@TestSuiteId[-:](\\d+)", Pattern.CASE_INSENSITIVE);
    
    // Track test executions across threads
    private static final java.util.concurrent.atomic.AtomicInteger testCounter = new java.util.concurrent.atomic.AtomicInteger(0);
    private static final Map<String, Integer> threadTestCount = new java.util.concurrent.ConcurrentHashMap<>();
    private static final Map<Long, Boolean> threadHasMoreTests = new java.util.concurrent.ConcurrentHashMap<>();
    
    // Dynamic test executor for work distribution
    private static CSDynamicTestExecutor dynamicExecutor;
    
    // Track feature file isolation
    private static final Map<String, Set<String>> featureScenarioMap = new java.util.concurrent.ConcurrentHashMap<>();
    
    // Track iteration numbers for each scenario outline
    private static final Map<String, java.util.concurrent.atomic.AtomicInteger> scenarioIterationMap = new java.util.concurrent.ConcurrentHashMap<>();
    
    // Track which threads have finished their tests
    private static final java.util.concurrent.atomic.AtomicInteger completedTests = new java.util.concurrent.atomic.AtomicInteger(0);
    private static volatile int totalExpectedTests = 0; // Will be set dynamically
    
    private String suiteName; // Store suite name for later use
    
    @BeforeClass
    @Parameters({"cs.bdd.features.path", "cs.bdd.tags", "cs.bdd.exclude.tags", "cs.bdd.stepdefs.packages", 
                 "cs.azure.devops.test.plan.id", "cs.azure.devops.test.suite.id", "cs.azure.devops.enabled"})
    public void setupBDDRunner(
            @org.testng.annotations.Optional("features") String featuresPath,
            @org.testng.annotations.Optional("") String tags,
            @org.testng.annotations.Optional("") String excludeTags,
            @org.testng.annotations.Optional("") String stepDefPackages,
            @org.testng.annotations.Optional("") String testPlanId,
            @org.testng.annotations.Optional("") String testSuiteId,
            @org.testng.annotations.Optional("") String adoEnabled,
            ITestContext context) {
        
        logger.info("@BeforeClass - Setting up BDD Runner on thread: {}", 
            Thread.currentThread().getName());
        
        // Call parent setupClass to initialize base test components
        super.setupClass(context);
        
        // Store suite name for ADO test run naming
        this.suiteName = context.getSuite().getName();
        logger.info("Test Suite Name: {}", this.suiteName);
        
        this.featuresPath = featuresPath;
        this.tagsToRun = tags;
        this.tagsToExclude = excludeTags;
        this.stepDefPackages = stepDefPackages;
        
        // Store suite XML parameters for ADO (highest priority)
        this.suiteXmlTestPlanId = testPlanId;
        this.suiteXmlTestSuiteId = testSuiteId;
        this.suiteAdoEnabled = adoEnabled;
        
        if (testPlanId != null && !testPlanId.isEmpty()) {
            logger.info("Test Plan ID from suite XML: {}", testPlanId);
        }
        if (testSuiteId != null && !testSuiteId.isEmpty()) {
            logger.info("Test Suite ID from suite XML: {}", testSuiteId);
        }
        this.featureParser = new CSFeatureParser();
        this.scenarioRunner = new CSScenarioRunner();
        
        // Reset counters
        testCounter.set(0);
        completedTests.set(0);
        threadTestCount.clear();
        scenarioIterationMap.clear();
        
        // Register step definition classes
        registerStepDefinitions();
        
        logger.info("BDD Runner initialized - Features: {}, Tags: {}, Exclude: {}", 
            featuresPath, tags, excludeTags);
        
        // Discover feature files
        discoverFeatureFiles();
        
        // Initialize Azure DevOps integration if enabled
        initializeADOIfEnabled();
    }
    
    @AfterMethod(alwaysRun = true)
    @Override
    public void teardownTest(Method method, ITestResult result) {
        String threadName = Thread.currentThread().getName();
        logger.info("[{}] @AfterMethod for test: {}", threadName, method.getName());
        
        // Call parent teardown - this handles screenshots and cleanup based on configuration
        super.teardownTest(method, result);
        
        // Check if browser should be closed after each test
        boolean reuseBrowser = config.getBooleanProperty("cs.browser.reuse.instance", true);
        if (!reuseBrowser) {
            // Clear ThreadLocal data when browser is not reused
            logger.info("[{}] Browser reuse=false - clearing ThreadLocal data", threadName);
            CSThreadLocalStepRegistry.clearThreadData();
        }
        
        // Parent teardown already handles browser lifecycle based on cs.browser.reuse.instance
        // No need for additional browser closing here - let the framework handle it
        // Browsers will be closed:
        // - After each test if reuse=false
        // - At the end of class/suite if reuse=true
        // - Each thread manages its own browser in parallel mode
    }
    
    @AfterClass(alwaysRun = true)
    public void teardownBDDRunner() {
        String threadName = Thread.currentThread().getName();
        logger.info("BDD Runner @AfterClass for thread: {}", threadName);
        
        // Clear ThreadLocal data for this thread
        logger.info("[{}] Clearing ThreadLocal data in @AfterClass", threadName);
        CSThreadLocalStepRegistry.clearThreadData();
        
        // Clear page manager ThreadLocal instances for this thread
        if (isClassAvailable("com.testforge.cs.page.CSPageManager")) {
            try {
                Class<?> pageManagerClass = Class.forName("com.testforge.cs.page.CSPageManager");
                pageManagerClass.getMethod("clearThreadPages").invoke(null);
                logger.info("[{}] Cleared CSPageManager page instances", threadName);
            } catch (Exception e) {
                logger.debug("Could not clear CSPageManager: {}", e.getMessage());
            }
        }
        
        // CRITICAL FIX: Close ALL browsers from ALL threads, not just current thread
        logger.info("[{}] Closing ALL browsers from all threads", threadName);
        CSWebDriverManager.quitAllDrivers();
        driver = null;
        
        // Add delay to ensure cleanup completes before moving on
        try {
            Thread.sleep(2000);
            logger.info("[{}] Waited 2 seconds for browser cleanup to complete", threadName);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Force final cleanup - kill any remaining chrome processes
        try {
            logger.info("[{}] Performing force cleanup of any remaining browser processes", threadName);
            Runtime.getRuntime().exec(new String[]{"pkill", "-f", "chrome"});
            Thread.sleep(1000);
        } catch (Exception e) {
            logger.debug("[{}] Force cleanup had issues (this is normal): {}", threadName, e.getMessage());
        }
        
        // Call parent teardown to ensure proper cleanup chain
        super.teardownClass();
        
        logger.info("Test execution summary for this class instance:");
        logger.info("  Total tests executed: {}", testCounter.get());
        logger.info("  Thread distribution: {}", threadTestCount);
    }
    
    @AfterSuite(alwaysRun = true)
    @Override
    public void teardownSuite() {
        logger.info("BDD Runner @AfterSuite - Ensuring all browsers are closed");
        
        // Complete the ADO test run if one was started
        if (adoPublisher != null && adoPublisher.isEnabled() && adoTestRunStarted) {
            try {
                // Don't call publishTestResults() here as test results are already published individually
                // Just complete the test run
                adoPublisher.completeTestRun();
                logger.info("Completed Azure DevOps test run");
            } catch (Exception e) {
                logger.error("Failed to complete ADO test run", e);
            }
        } else if (adoPublisher != null && adoPublisher.isEnabled() && !adoTestRunStarted) {
            logger.info("No ADO test run was created as no tests had complete ADO mapping (TestPlanId, TestSuiteId, and TestCaseId)");
        }
        
        // Call parent teardownSuite (generates report, etc.)
        super.teardownSuite();
        
        // Double-check that all browsers are closed
        CSWebDriverManager.quitAllDrivers();
        
        logger.info("Final test execution summary:");
        logger.info("  Total tests completed: {}/{}", completedTests.get(), totalExpectedTests);
        logger.info("  Thread distribution: {}", threadTestCount);
    }
    
    /**
     * Register step definition classes
     * Override this method to register your step definitions
     */
    protected void registerStepDefinitions() {
        // Dynamic package scanning for step definitions
        try {
            // Use parameter if provided, otherwise fall back to config property
            String packagesToScan = (this.stepDefPackages != null && !this.stepDefPackages.trim().isEmpty()) 
                ? this.stepDefPackages 
                : config.getProperty("cs.bdd.stepdefs.packages", "com.orangehrm.stepdefs");
            
            logger.info("Scanning for step definitions in packages: {}", packagesToScan);
            
            CSStepRegistry registry = CSStepRegistry.getInstance();
            
            // Split comma-separated packages and scan each one
            String[] packages = packagesToScan.split(",");
            for (String packageName : packages) {
                String trimmedPackage = packageName.trim();
                if (!trimmedPackage.isEmpty()) {
                    logger.info("Scanning package: {}", trimmedPackage);
                    registry.scanPackage(trimmedPackage);
                    
                    // Also register with ThreadLocal registry for thread safety
                    registerPackageWithThreadLocal(trimmedPackage);
                }
            }
            
            // Log the registered steps count
            int totalSteps = registry.getAllSteps().values().stream()
                .mapToInt(List::size)
                .sum();
            logger.info("Total step definitions registered: {}", totalSteps);
            
        } catch (Exception e) {
            logger.error("Failed to register step definitions", e);
        }
    }
    
    /**
     * Register step classes with ThreadLocal registry for thread safety
     */
    private void registerPackageWithThreadLocal(String packageName) {
        try {
            // Get step classes from the existing singleton registry instead of filesystem scanning
            CSStepRegistry registry = CSStepRegistry.getInstance();
            Map<Class<?>, Object> stepInstances = registry.getStepInstances();
            
            int registeredCount = 0;
            for (Class<?> stepClass : stepInstances.keySet()) {
                // Check if the class belongs to this package
                if (stepClass.getPackage() != null && 
                    stepClass.getPackage().getName().startsWith(packageName)) {
                    CSThreadLocalStepRegistry.registerStepClass(stepClass);
                    registeredCount++;
                }
            }
            
            logger.info("Registered {} step classes with ThreadLocal registry from package: {}", 
                registeredCount, packageName);
        } catch (Exception e) {
            logger.error("Failed to register package {} with ThreadLocal registry", packageName, e);
        }
    }
    
    
    /**
     * Discover all feature files in the specified path
     */
    private void discoverFeatureFiles() {
        try {
            featureFiles.clear();
            
            // Support comma-separated paths
            String[] paths = featuresPath.split(",");
            
            for (String pathStr : paths) {
                String trimmedPath = pathStr.trim();
                if (trimmedPath.isEmpty()) continue;
                
                Path path = Paths.get(trimmedPath);
                
                // Check if it's a specific feature file
                if (trimmedPath.endsWith(".feature")) {
                    if (Files.exists(path)) {
                        featureFiles.add(path.toString());
                        logger.info("Added feature file: {}", path);
                    } else {
                        logger.warn("Feature file not found: {}", path);
                    }
                } else {
                    // It's a directory, scan for feature files
                    if (!Files.exists(path)) {
                        logger.warn("Features directory does not exist: {}", trimmedPath);
                        continue;
                    }
                    
                    List<String> foundFiles = Files.walk(path)
                        .filter(p -> p.toString().endsWith(".feature"))
                        .map(Path::toString)
                        .collect(Collectors.toList());
                    
                    featureFiles.addAll(foundFiles);
                    logger.info("Discovered {} feature files in: {}", foundFiles.size(), trimmedPath);
                }
            }
            
            logger.info("Total feature files discovered: {}", featureFiles.size());
            
            if (featureFiles.isEmpty()) {
                throw new RuntimeException("No feature files found in paths: " + featuresPath);
            }
            
        } catch (Exception e) {
            logger.error("Failed to discover feature files", e);
            throw new RuntimeException("Failed to discover feature files", e);
        }
    }
    
    /**
     * Data provider for feature files
     * Uses parallel=true to enable parallel capability
     * The suite's parallel attribute controls actual execution:
     * - parallel="none" → Sequential (TestNG should respect this)
     * - parallel="methods" → Parallel execution
     * 
     * Note: There's a TestNG quirk where DataProvider parallel=true can override suite parallel="none"
     * To force sequential: Set suite parallel="none" AND set -Dtestng.data-provider-thread-count=1
     */
    @DataProvider(name = "featureFiles", parallel = true)
    public Object[][] getFeatureFiles(ITestContext context) {
        System.out.println("\n>>> DataProvider getFeatureFiles() called <<<");
        List<Object[]> testData = new ArrayList<>();
        
        // Get parallel mode from suite configuration
        String parallelMode = context.getSuite().getParallel();
        boolean isParallel = parallelMode != null && !parallelMode.equals("none") && !parallelMode.equals("false");
        
        // Initialize dynamic executor for parallel mode
        int threadCount = context.getSuite().getXmlSuite().getThreadCount();
        if (isParallel && threadCount > 1) {
            if (dynamicExecutor == null) {
                dynamicExecutor = CSDynamicTestExecutor.getInstance(threadCount);
                dynamicExecutor.reset();
                logger.info("Initialized dynamic test executor with {} threads", threadCount);
            }
        }
        
        // IMPORTANT: Control thread count based on suite configuration
        if (!isParallel) {
            // Force sequential execution
            System.setProperty("testng.data-provider-thread-count", "1");
            context.getSuite().getXmlSuite().setDataProviderThreadCount(1);
            logger.info("Suite has parallel='{}' - Forcing sequential execution by setting data-provider-thread-count=1", parallelMode);
        } else {
            // For parallel mode, ensure proper thread pool configuration
            int suiteThreadCount = context.getSuite().getXmlSuite().getThreadCount();
            if (suiteThreadCount > 0) {
                // Set data provider thread count to match suite thread count
                System.setProperty("testng.data-provider-thread-count", String.valueOf(suiteThreadCount));
                context.getSuite().getXmlSuite().setDataProviderThreadCount(suiteThreadCount);
                
                // Also set TestNG's default thread pool size to ensure proper distribution
                System.setProperty("dataproviderthreadcount", String.valueOf(suiteThreadCount));
                
                logger.info("Suite has thread-count={}, configured data provider with {} threads", 
                    suiteThreadCount, suiteThreadCount);
            }
        }
        
        // Implement hierarchical thread count determination
        // Priority: 1. thread-count from XML, 2. data-provider-thread-count from XML, 3. application.properties
        int dataProviderThreadCount = -1;
        String threadCountSource = "unknown";
        
        // Get XmlSuite for accessing attributes
        org.testng.xml.XmlSuite xmlSuite = context.getSuite().getXmlSuite();
        
        if (xmlSuite != null) {
            int xmlThreadCount = xmlSuite.getThreadCount();
            int xmlDataProviderThreadCount = xmlSuite.getDataProviderThreadCount();
            
            // Check if data-provider-thread-count is explicitly set (not default value of 10)
            boolean hasExplicitDataProviderThreadCount = xmlDataProviderThreadCount != 10;
            
            // Check if thread-count is explicitly set (not default value of 1)
            boolean hasExplicitThreadCount = xmlThreadCount > 1;
            
            // Priority logic based on user requirement:
            // 1. If thread-count is explicitly set, use it as the default for data-provider-thread-count
            // 2. However, if data-provider-thread-count is ALSO explicitly set, override with that (more specific)
            // 3. Otherwise fall back to application.properties
            
            if (hasExplicitThreadCount) {
                // thread-count is explicitly set, use it as default
                dataProviderThreadCount = xmlThreadCount;
                threadCountSource = "thread-count attribute from suite XML";
                logger.info("Using thread-count={} from suite XML as default for data-provider-thread-count", xmlThreadCount);
                
                // But check if data-provider-thread-count overrides it
                if (hasExplicitDataProviderThreadCount) {
                    dataProviderThreadCount = xmlDataProviderThreadCount;
                    threadCountSource = "data-provider-thread-count attribute from suite XML (overrides thread-count)";
                    logger.info("Note: Both thread-count={} and data-provider-thread-count={} are specified. " +
                               "Using data-provider-thread-count={} as it explicitly overrides the thread-count default.", 
                               xmlThreadCount, xmlDataProviderThreadCount, xmlDataProviderThreadCount);
                }
            } else if (hasExplicitDataProviderThreadCount) {
                // Only data-provider-thread-count is explicitly set
                dataProviderThreadCount = xmlDataProviderThreadCount;
                threadCountSource = "data-provider-thread-count attribute from suite XML";
                logger.info("Using data-provider-thread-count={} from suite XML", xmlDataProviderThreadCount);
            }
        }
        
        // Third priority: Fall back to application.properties
        if (dataProviderThreadCount <= 0 || dataProviderThreadCount == 10) {
            String propertyThreadCount = config.getProperty("cs.test.thread.count", "1");
            try {
                dataProviderThreadCount = Integer.parseInt(propertyThreadCount);
                threadCountSource = "cs.test.thread.count from application.properties";
                logger.info("No thread count specified in suite XML, using cs.test.thread.count={} from application.properties", dataProviderThreadCount);
            } catch (NumberFormatException e) {
                logger.warn("Invalid cs.test.thread.count in application.properties: {}, using default of 1", propertyThreadCount);
                dataProviderThreadCount = 1;
                threadCountSource = "default fallback";
            }
        }
        
        // Allow system property override if needed
        String systemThreadCount = System.getProperty("testng.data-provider-thread-count");
        if (systemThreadCount != null) {
            try {
                int overrideCount = Integer.parseInt(systemThreadCount);
                logger.info("System property testng.data-provider-thread-count detected: {} (overrides {})", 
                    overrideCount, threadCountSource);
                // Note: We can't actually change TestNG's thread pool size here, but we log it for awareness
            } catch (NumberFormatException e) {
                logger.warn("Invalid system property testng.data-provider-thread-count: {}", systemThreadCount);
            }
        }
        
        logger.info("DataProvider method called on thread: {} (parallel mode: {})", 
                Thread.currentThread().getName(), parallelMode);
        
        // Log intelligent parallel handling
        if (isParallel) {
            logger.info("Parallel execution detected (mode: {}). DataProvider will run tests concurrently.", parallelMode);
            logger.info("TestNG is using data-provider-thread-count={} (source: {})", dataProviderThreadCount, threadCountSource);
            logger.info("Thread count hierarchy: thread-count (XML) -> data-provider-thread-count (XML) -> application.properties");
        } else {
            logger.info("Sequential execution mode. DataProvider will run tests one at a time.");
            logger.info("Parallel mode is set to: {}", parallelMode != null ? parallelMode : "not specified (defaulting to none)");
        }
        
        for (String featureFile : featureFiles) {
            try {
                CSFeatureFile feature = featureParser.parseFeatureFile(featureFile);
                
                // Check if feature should be included based on tags
                boolean includeFeature = shouldIncludeFeature(feature);
                
                if (includeFeature) {
                    // If feature is included, run all its scenarios
                    logger.info("Feature {} is included, has {} scenarios", feature.getName(), feature.getScenarios().size());
                    for (CSFeatureFile.Scenario scenario : feature.getScenarios()) {
                        logger.info("Adding scenario to test data: {} with {} steps", 
                            scenario.getName(), scenario.getSteps().size());
                        testData.add(new Object[]{featureFile, feature, scenario});
                        
                        // Add to dynamic executor queue if in parallel mode
                        if (dynamicExecutor != null) {
                            dynamicExecutor.addTest(new CSDynamicTestExecutor.TestScenario(featureFile, feature, scenario));
                        }
                    }
                } else {
                    // Otherwise, filter scenarios by tags
                    logger.info("Feature {} is not included at feature level, checking scenarios individually", feature.getName());
                    List<CSFeatureFile.Scenario> scenarios = filterScenariosByTags(feature.getScenarios());
                    logger.info("Found {} matching scenarios out of {}", scenarios.size(), feature.getScenarios().size());
                    
                    for (CSFeatureFile.Scenario scenario : scenarios) {
                        logger.debug("Adding filtered scenario to test data: {} with {} steps", 
                            scenario.getName(), scenario.getSteps().size());
                        // Debug: Log first few steps
                        if (scenario.getSteps() != null && !scenario.getSteps().isEmpty()) {
                            for (int i = 0; i < Math.min(3, scenario.getSteps().size()); i++) {
                                CSFeatureFile.Step step = scenario.getSteps().get(i);
                                logger.info("  Step {}: {} {}", i+1, step.getKeyword(), step.getText());
                            }
                        }
                        testData.add(new Object[]{featureFile, feature, scenario});
                        
                        // Add to dynamic executor queue if in parallel mode
                        if (dynamicExecutor != null) {
                            dynamicExecutor.addTest(new CSDynamicTestExecutor.TestScenario(featureFile, feature, scenario));
                        }
                    }
                }
                
            } catch (Exception e) {
                logger.error("Failed to parse feature file: {}", featureFile, e);
            }
        }
        
        logger.info("DataProvider created {} total test scenarios", testData.size());
        
        // Log scenario details for debugging
        Map<String, Integer> scenarioCount = new HashMap<>();
        for (int i = 0; i < testData.size(); i++) {
            Object[] test = testData.get(i);
            CSFeatureFile.Scenario scenario = (CSFeatureFile.Scenario) test[2];
            String scenarioName = scenario.getName();
            scenarioCount.merge(scenarioName, 1, Integer::sum);
            logger.info("Test #{}: {} - Data: {}", i + 1, scenario.getName(), scenario.getDataRow());
        }
        
        // Log summary
        logger.info("=== SCENARIO SUMMARY ===");
        scenarioCount.forEach((name, count) -> 
            logger.info("  {}: {} instances", name, count));
        
        // Log thread pool information
        logger.info("DataProvider returning {} test cases, parallel={}", testData.size(), true);
        logger.info("Expected to run on {} threads (source: {})", dataProviderThreadCount, threadCountSource);
        
        // Set the total expected tests for cleanup tracking
        totalExpectedTests = testData.size();
        logger.info("Total expected tests set to: {}", totalExpectedTests);
        
        // Print to console for debugging
        System.out.println("\n========== DATAPROVIDER SUMMARY ==========");
        System.out.println("Total test scenarios created: " + testData.size());
        scenarioCount.forEach((name, count) -> 
            System.out.println("  " + name + ": " + count + " instances"));
        System.out.println("==========================================\n");
        
        // Collect test points for ADO if enabled
        if (adoPublisher != null && adoPublisher.isEnabled()) {
            collectTestPointsAndCreateTestRun(testData);
        }
        
        return testData.toArray(new Object[0][]);
    }
    
    @Override
    @BeforeMethod(alwaysRun = true)
    public void setupTest(Method method, Object[] params, ITestContext context) {
        String threadName = Thread.currentThread().getName();
        long threadId = Thread.currentThread().getId();
        logger.info("[{}] @BeforeMethod for: {}", threadName, method.getName());
        
        // Check configuration for browser reuse
        boolean reuseBrowser = config.getBooleanProperty("cs.browser.reuse.instance", true);
        String parallelMode = context.getSuite().getParallel();
        boolean isParallel = parallelMode != null && !parallelMode.equals("none") && !parallelMode.equals("false");
        
        if (isParallel && !reuseBrowser) {
            // In parallel mode with reuse disabled, ensure clean browser for each test
            WebDriver existingDriver = CSWebDriverManager.getDriver();
            if (existingDriver != null) {
                logger.info("[{}] Parallel mode with reuse=false - closing existing browser", threadName);
                try {
                    CSWebDriverManager.quitDriver();
                    driver = null;
                } catch (Exception e) {
                    logger.warn("[{}] Error closing existing browser: {}", threadName, e.getMessage());
                }
            }
        } else if (isParallel && reuseBrowser) {
            // In parallel mode with reuse enabled, each thread maintains its own browser
            // The parent setupTest will handle this correctly - reuse within thread
            logger.info("[{}] Parallel mode with reuse=true - thread will reuse its browser", threadName);
        }
        
        // Call parent setup - this handles browser creation/reuse based on configuration
        super.setupTest(method, params, context);
        
        logger.info("[{}] After parent setup, driver = {}", threadName, driver);
        
        // IMPORTANT: Each thread needs its own driver instance properly set
        // The parent setupTest creates a new driver, now we need to ensure it's properly
        // registered in all the thread-local storages
        if (driver != null) {
            // Create CSDriver wrapper for this specific thread
            CSDriver csDriver = new CSDriver(driver);
            
            // Set in CSStepDefinitions ThreadLocal - this is critical for step execution
            CSStepDefinitions.setDriver(csDriver);
            
            // Also ensure it's in CSWebDriverManager's ThreadLocal
            CSWebDriverManager.setDriver(driver);
            
            // Log to verify the driver is properly set for this thread
            logger.info("[{}] Thread ID {} - Driver properly initialized and set in all ThreadLocals", threadName, threadId);
            logger.info("[{}] CSWebDriverManager.getDriver() = {}", threadName, CSWebDriverManager.getDriver());
            logger.info("[{}] Driver hashCode = {}", threadName, driver.hashCode());
            
            // Now that WebDriver is ready, inject @CSPageInjection annotated pages
            injectPagesIntoStepDefinitions(threadName);
        } else {
            logger.error("[{}] CRITICAL: Driver is null after parent setup! Thread ID: {}", threadName, threadId);
            throw new RuntimeException("Failed to initialize driver for thread: " + threadName);
        }
    }
    
    /**
     * Initialize ThreadLocal pages for this thread now that WebDriver is ready.
     */
    private void injectPagesIntoStepDefinitions(String threadName) {
        try {
            logger.info("[{}] Initializing ThreadLocal pages for this thread", threadName);
            
            // Initialize ThreadLocal step instances with page injection
            CSThreadLocalStepRegistry.initializeThreadPages();
            
            // Also inject pages into old singleton step definitions for backward compatibility
            Map<Class<?>, Object> stepInstances = CSStepRegistry.getStepClassInstances();
            
            for (Map.Entry<Class<?>, Object> entry : stepInstances.entrySet()) {
                Object stepInstance = entry.getValue();
                if (stepInstance instanceof CSStepDefinitions) {
                    CSStepDefinitions stepDef = (CSStepDefinitions) stepInstance;
                    stepDef.injectAnnotatedPages();
                    logger.debug("[{}] Injected pages for singleton: {}", threadName, entry.getKey().getSimpleName());
                }
            }
            
            logger.info("[{}] Page initialization completed for thread", threadName);
            
        } catch (Exception e) {
            logger.warn("[{}] Failed to initialize pages for thread: {}", threadName, e.getMessage());
            // Don't fail the test - just log the warning and continue
        }
    }
    
    /**
     * Test method that executes each scenario
     */
    @Test(dataProvider = "featureFiles", description = "Execute BDD Scenario", singleThreaded = false)
    public void executeBDDScenario(String featureFile, CSFeatureFile feature, CSFeatureFile.Scenario scenario) {
        // Log thread and isolation information
        String threadName = Thread.currentThread().getName();
        long threadId = Thread.currentThread().getId();
        
        // Add thread synchronization to prevent race conditions during parallel startup
        int testNumber;
        synchronized (CSBDDRunner.class) {
            testNumber = testCounter.incrementAndGet();
            logger.info("[{}] Thread ID {} Starting test #{} for scenario: {} with data: {}", 
                threadName, threadId, testNumber, scenario.getName(), scenario.getDataRow());
            
            // Small stagger for thread initialization to prevent browser creation conflicts
            if (testNumber <= 2) {
                try {
                    Thread.sleep(500 * testNumber); // 500ms for first test, 1000ms for second
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        
        logger.info("[ISOLATION] Feature file: {}, Feature name: {}, Scenario: {}", 
            featureFile, feature.getName(), scenario.getName());
        
        // Track thread distribution
        threadTestCount.merge(threadName, 1, Integer::sum);
        
        logger.info("Test execution #{} - Thread: {} (total tests on this thread: {}), Scenario: {}, Data Source: {}", 
            testNumber, threadName, threadTestCount.get(threadName), scenario.getName(), 
            scenario.getExamplesConfig() != null ? scenario.getExamplesConfig() : "Unknown");
        
        // Log thread pool status
        if (testNumber == 1 || testNumber == 4 || testNumber == 7 || testNumber == 10 || testNumber == 12) {
            logger.info("Thread distribution after {} tests: {}", testNumber, threadTestCount);
        }
        
        // Verify driver is available from multiple sources
        logger.info("[{}] Test #{} - Verifying driver availability", threadName, testNumber);
        logger.info("[{}] - Instance driver field: {}", threadName, driver != null ? "AVAILABLE" : "NULL");
        logger.info("[{}] - CSWebDriverManager.getDriver(): {}", threadName, CSWebDriverManager.getDriver() != null ? "AVAILABLE" : "NULL");
        
        // Critical check - ensure driver is properly initialized for this thread
        if (driver == null) {
            logger.error("[{}] CRITICAL ERROR: Instance driver is null at start of test execution!", threadName);
            throw new RuntimeException("Driver not initialized for thread: " + threadName);
        }
        
        if (CSWebDriverManager.getDriver() == null) {
            logger.error("[{}] CRITICAL ERROR: CSWebDriverManager.getDriver() is null!", threadName);
            logger.warn("[{}] Attempting to re-set driver in CSWebDriverManager", threadName);
            CSWebDriverManager.setDriver(driver);
            
            if (CSWebDriverManager.getDriver() == null) {
                throw new RuntimeException("Failed to set driver in CSWebDriverManager for thread: " + threadName);
            }
        }
        
        // Re-ensure CSStepDefinitions has the driver for this thread
        CSDriver csDriver = new CSDriver(driver);
        CSStepDefinitions.setDriver(csDriver);
        logger.info("[{}] Test #{} - Driver re-verified and set in all contexts", threadName, testNumber);
        
        // Track scenario execution per feature file
        featureScenarioMap.computeIfAbsent(featureFile, k -> new HashSet<>()).add(scenario.getName());
        
        // Create a new scenario runner for each test to ensure thread safety and feature isolation
        CSScenarioRunner threadSafeScenarioRunner = new CSScenarioRunner();
        
        // Build proper scenario name with iteration number for data-driven tests
        String scenarioDisplayName = scenario.getName();
        String baseScenarioName = scenario.getName(); // Keep original name for tracking
        
        // For data-driven scenarios (Scenario Outlines with Examples), add iteration number
        if (scenario.getDataRow() != null && !scenario.getDataRow().isEmpty()) {
            // Get or create iteration counter for this scenario
            java.util.concurrent.atomic.AtomicInteger iterationCounter = 
                scenarioIterationMap.computeIfAbsent(baseScenarioName, 
                    k -> new java.util.concurrent.atomic.AtomicInteger(0));
            
            // Increment and get the iteration number
            int iterationNumber = iterationCounter.incrementAndGet();
            
            // Format: ScenarioName_Iteration<number>
            scenarioDisplayName = baseScenarioName + "_Iteration" + iterationNumber;
            
            logger.info("Data-driven scenario: {} (Iteration {})", baseScenarioName, iterationNumber);
            logger.info("Data row for iteration {}: {}", iterationNumber, scenario.getDataRow());
        }
        
        // Ensure we have a valid scenario name
        if (scenarioDisplayName == null || scenarioDisplayName.trim().isEmpty()) {
            scenarioDisplayName = "Unnamed Scenario";
            logger.warn("Scenario has no name, using default: {}", scenarioDisplayName);
        }
        
        // Ensure we have a valid feature name
        String featureName = feature.getName();
        if (featureName == null || featureName.trim().isEmpty()) {
            featureName = "Unnamed Feature";
            logger.warn("Feature has no name, using default: {}", featureName);
        }
        
        String scenarioName = featureName + " - " + scenarioDisplayName;
        
        // Log feature file isolation info
        logger.info("[ISOLATION] Executing scenario '{}' from feature file: {}", scenarioDisplayName, featureFile);
        logger.info("[ISOLATION] Feature '{}' has executed scenarios: {}", 
            featureName, featureScenarioMap.get(featureFile));
        logger.info("Executing scenario: {} (Tags: {}) - First step: {} {}", 
            scenarioName, scenario.getTags(), 
            scenario.getSteps().isEmpty() ? "NO STEPS" : scenario.getSteps().get(0).getKeyword(),
            scenario.getSteps().isEmpty() ? "" : scenario.getSteps().get(0).getText());
        
        // Create test result
        CSTestResult testResult = new CSTestResult();
        testResult.setTestId(UUID.randomUUID().toString());
        testResult.setTestName(scenarioName);
        testResult.setDescription(scenario.getDescription() != null ? scenario.getDescription() : "");
        testResult.setTags(scenario.getTags());
        testResult.setClassName(this.getClass().getName());
        testResult.setMethodName("executeBDDScenario");
        testResult.setStartTime(LocalDateTime.now());
        testResult.setEnvironment(config.getProperty("environment.name", "qa"));
        testResult.setBrowser(config.getProperty("browser.name", "chrome"));
        testResult.setThreadName(Thread.currentThread().getName());
        testResult.setScenarioName(scenarioDisplayName);
        
        // Set current test context for reporting
        CSReportManager.setCurrentTestContext(testResult.getTestId());
        
        // Set test data information if available
        if (scenario.getDataRow() != null && !scenario.getDataRow().isEmpty()) {
            logger.info("[{}] Scenario has data row: {}", threadName, scenario.getDataRow());
            Map<String, Object> testData = new HashMap<>();
            testData.putAll(scenario.getDataRow());
            
            // Determine data source type
            String dataSource = "Unknown";
            String sourceFile = "";
            
            // Check if it's from JSON configuration in Examples
            if (scenario.getExamplesConfig() != null) {
                try {
                    // Parse JSON configuration to extract source information
                    String config = scenario.getExamplesConfig();
                    if (config.contains("type")) {
                        if (config.contains("csv")) {
                            dataSource = "CSV";
                            // Extract source file path
                            int sourceStart = config.indexOf("source") + 9;
                            int sourceEnd = config.indexOf("\"", sourceStart);
                            if (sourceStart > 8 && sourceEnd > sourceStart) {
                                sourceFile = config.substring(sourceStart, sourceEnd);
                            }
                        } else if (config.contains("excel")) {
                            dataSource = "Excel";
                        } else if (config.contains("json")) {
                            dataSource = "JSON";
                        } else if (config.contains("database")) {
                            dataSource = "Database";
                        }
                    }
                } catch (Exception e) {
                    logger.warn("Failed to parse data source config: {}", e.getMessage());
                }
            } else {
                // Check tags for @CSDataSource
                for (String tag : scenario.getTags()) {
                    if (tag.contains("csv")) {
                        dataSource = "CSV";
                    } else if (tag.contains("excel")) {
                        dataSource = "Excel";
                    } else if (tag.contains("json")) {
                        dataSource = "JSON";
                    } else if (tag.contains("database")) {
                        dataSource = "Database";
                    }
                }
            }
            
            testData.put("dataSourceType", dataSource);
            testData.put("dataSourceFile", sourceFile);
            testResult.setTestData(testData);
        }
        
        // Set proper suite name and feature file
        testResult.setSuiteName(this.suiteName != null ? this.suiteName : "Test Suite");
        testResult.setFeatureFile(new File(featureFile).getName());
        
        // Extract ADO metadata if ADO is enabled
        CSADOTagExtractor.ADOMetadata adoMetadata = null;
        if (adoPublisher != null && adoPublisher.isEnabled()) {
            adoMetadata = extractADOMetadataFromScenario(feature, scenario);
            
            // Check if we have metadata (TestCaseId is required)
            if (adoMetadata != null) {
                // Check if ALL three IDs are present (TestPlan, TestSuite, and TestCase)
                if (adoMetadata.hasTestCaseMapping() && 
                    adoMetadata.getTestPlanId() != null && 
                    adoMetadata.getTestSuiteId() != null) {
                    
                    logger.info("Found complete ADO mapping for scenario - Test Cases: {}, Test Plan: {}, Test Suite: {}", 
                        adoMetadata.getTestCaseIds(), 
                        adoMetadata.getTestPlanId(), 
                        adoMetadata.getTestSuiteId());
                    
                    // Test run should already be created with test points in DataProvider
                    // Just log that we have ADO mapping
                    
                    // Add ADO metadata to test result
                    if (testResult.getMetadata() == null) {
                        testResult.setMetadata(new HashMap<>());
                    }
                    Map<String, String> metadataMap = CSADOTagExtractor.toMetadataMap(adoMetadata);
                    testResult.getMetadata().putAll(metadataMap);
                } else {
                    // Log which IDs are missing (TestCaseId is present but other IDs missing)
                    List<String> missingIds = new ArrayList<>();
                    if (adoMetadata.getTestPlanId() == null) {
                        missingIds.add("TestPlanId");
                    }
                    if (adoMetadata.getTestSuiteId() == null) {
                        missingIds.add("TestSuiteId");
                    }
                    logger.info("Skipping ADO integration for scenario '{}' (TestCase: {}) - Missing IDs: {}", 
                        scenario.getName(), adoMetadata.getTestCaseId(), String.join(", ", missingIds));
                }
            } else {
                // No TestCaseId found - already logged in extractADOMetadataFromScenario
                logger.debug("ADO integration skipped for scenario '{}' - no TestCaseId", scenario.getName());
            }
        }
        
        try {
            // Create a deep copy of the scenario to avoid thread and feature interference
            CSFeatureFile.Scenario scenarioCopy = createScenarioCopy(scenario);
            
            // Ensure complete isolation by clearing any shared state
            ensureScenarioIsolation(threadName, featureFile, feature.getName(), scenario.getName());
            
            // Log driver instance and scenario data
            logger.info("[{}] Driver instance: {}", threadName, driver);
            logger.info("[{}] CSWebDriverManager driver: {}", threadName, CSWebDriverManager.getDriver());
            logger.info("[{}] Scenario copy data row: {}", threadName, scenarioCopy.getDataRow());
            
            // Execute scenario with the copy and feature file context
            threadSafeScenarioRunner.runScenarioFromFile(featureFile, feature, scenarioCopy);
            
            // Get executed steps from scenario context
            Map<String, Object> scenarioContext = threadSafeScenarioRunner.getScenarioContext();
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> executedSteps = (List<Map<String, Object>>) scenarioContext.get("executed_steps");
            logger.info("Retrieved executed steps from context: {} steps", executedSteps != null ? executedSteps.size() : "null");
            if (executedSteps != null && !executedSteps.isEmpty()) {
                logger.info("Setting {} executed steps to test result", executedSteps.size());
                testResult.setExecutedSteps(executedSteps);
            } else {
                logger.warn("No executed steps found in scenario context for: {}", scenarioName);
            }
            
            // Check if any steps have soft-failed
            boolean hasFailedSteps = false;
            if (executedSteps != null) {
                hasFailedSteps = executedSteps.stream()
                    .anyMatch(step -> {
                        String status = (String) step.get("status");
                        Boolean softFailed = (Boolean) step.get("softFailed");
                        return "failed".equals(status) || (softFailed != null && softFailed);
                    });
            }
            
            if (hasFailedSteps) {
                testResult.setStatus(CSTestResult.Status.FAILED);
                testResult.setErrorMessage("Scenario contains soft-failed steps");
                reportManager.logInfo("Scenario failed due to soft-failed steps: " + scenarioName);
            } else {
                testResult.setStatus(CSTestResult.Status.PASSED);
                reportManager.logInfo("Scenario passed: " + scenarioName);
            }
            
        } catch (Exception e) {
            testResult.setStatus(CSTestResult.Status.FAILED);
            testResult.setErrorMessage(e.getMessage());
            testResult.setStackTrace(getStackTrace(e));
            testResult.setEndTime(LocalDateTime.now());
            testResult.setDuration(testResult.calculateDuration());
            
            // Perform intelligent failure analysis
            // Use root cause if available for better categorization
            Throwable rootCause = e;
            while (rootCause.getCause() != null) {
                rootCause = rootCause.getCause();
            }
            
            // Log the actual exception being analyzed
            logger.debug("Analyzing exception: {} with message: {}", 
                rootCause.getClass().getName(), rootCause.getMessage());
            
            CSFailureAnalyzer.FailureAnalysis analysis = CSFailureAnalyzer.analyzeFailure(
                rootCause, 
                scenarioName, 
                this.getClass().getName()
            );
            testResult.setFailureAnalysis(analysis);
            
            // Log the analysis results
            logger.info("Failure Analysis for {}: Category={}, Flaky={}, Score={}", 
                scenarioName, 
                analysis.getCategory().getDisplayName(),
                analysis.isFlaky(),
                String.format("%.2f", analysis.getFlakinessScore())
            );
            
            // Get executed steps even on failure
            Map<String, Object> scenarioContext = threadSafeScenarioRunner.getScenarioContext();
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> executedSteps = (List<Map<String, Object>>) scenarioContext.get("executed_steps");
            logger.info("Retrieved executed steps from context on failure: {} steps", executedSteps != null ? executedSteps.size() : "null");
            if (executedSteps != null && !executedSteps.isEmpty()) {
                logger.info("Setting {} executed steps to test result on failure", executedSteps.size());
                testResult.setExecutedSteps(executedSteps);
            } else {
                logger.warn("No executed steps found in scenario context on failure for: {}", scenarioName);
            }
            
            // Try to capture screenshot on failure
            try {
                if (CSWebDriverManager.getDriver() != null) {
                    // ALWAYS capture a fresh screenshot for the actual test failure
                    // Do NOT reuse soft-fail screenshots as they show different failure points
                    byte[] screenshot = CSScreenshotUtils.captureScreenshot(CSWebDriverManager.getDriver());
                    if (screenshot != null && screenshot.length > 0) {
                        String screenshotName = "ACTUAL_FAILURE_executeBDDScenario_" + System.currentTimeMillis();
                        String path = reportManager.attachScreenshot(screenshot, screenshotName);
                        if (path != null) {
                            testResult.setScreenshotPath(path);
                            logger.info("Fresh screenshot captured for actual test failure: {}", path);
                        }
                    } else {
                        logger.warn("Could not capture fresh screenshot for test failure, will check for soft-fail fallback");
                        
                        // Only as a fallback, if we can't capture a fresh screenshot, use soft-fail
                        boolean foundSoftFailScreenshot = false;
                        if (scenarioContext != null && executedSteps != null) {
                            for (Map<String, Object> step : executedSteps) {
                                @SuppressWarnings("unchecked")
                                List<Map<String, Object>> actions = (List<Map<String, Object>>) step.get("actions");
                                if (actions != null) {
                                    for (Map<String, Object> action : actions) {
                                        String actionType = (String) action.get("actionType");
                                        String type = (String) action.get("type");
                                        String fallbackScreenshot = (String) action.get("screenshot");
                                            
                                        if (("FAIL".equals(actionType) || "FAIL".equals(type)) && fallbackScreenshot != null && fallbackScreenshot.startsWith("data:image/")) {
                                            testResult.setScreenshotPath(fallbackScreenshot);
                                            foundSoftFailScreenshot = true;
                                            logger.info("FALLBACK: Using soft-fail screenshot only because fresh capture failed: {}", scenarioName);
                                            break;
                                        }
                                    }
                                }
                                if (foundSoftFailScreenshot) break;
                            }
                        }
                    }
                }
            } catch (Exception screenshotError) {
                logger.warn("Failed to capture screenshot: {}", screenshotError.getMessage());
            }
            
            reportManager.logError("Scenario failed: " + scenarioName + " - " + e.getMessage());
            throw new RuntimeException("Scenario failed: " + scenarioName, e);
            
        } finally {
            // Set end time if not already set
            if (testResult.getEndTime() == null) {
                testResult.setEndTime(LocalDateTime.now());
                testResult.setDuration(testResult.calculateDuration());
            }
            
            // Publish to Azure DevOps if enabled and has complete mapping (all three IDs)
            if (adoPublisher != null && adoPublisher.isEnabled() && 
                testResult.getMetadata() != null && 
                testResult.getMetadata().containsKey("ado.testcase.id") &&
                testResult.getMetadata().containsKey("ado.testplan.id") &&
                testResult.getMetadata().containsKey("ado.testsuite.id")) {
                
                // Check if we have multiple test case IDs to update
                if (adoMetadata != null && adoMetadata.getTestCaseIds().size() > 1) {
                    // Multiple test cases - publish the same result for each test case
                    for (Integer testCaseId : adoMetadata.getTestCaseIds()) {
                        try {
                            // Update metadata for this specific test case
                            testResult.getMetadata().put("ado.testcase.id", testCaseId.toString());
                            adoPublisher.publishTestResult(testResult);
                            logger.info("Published test result to Azure DevOps for test case: {}", testCaseId);
                        } catch (Exception e) {
                            logger.error("Failed to publish result to ADO for test case: " + testCaseId, e);
                            // Don't fail the test if ADO publishing fails
                        }
                    }
                } else {
                    // Single test case - publish once
                    try {
                        adoPublisher.publishTestResult(testResult);
                        logger.info("Published test result to Azure DevOps for test case: {}", 
                            testResult.getMetadata().get("ado.testcase.id"));
                    } catch (Exception e) {
                        logger.error("Failed to publish result to ADO", e);
                        // Don't fail the test if ADO publishing fails
                    }
                }
            } else if (adoPublisher != null && adoPublisher.isEnabled() && testResult.getMetadata() != null) {
                // Log why we're not publishing
                List<String> missingIds = new ArrayList<>();
                if (!testResult.getMetadata().containsKey("ado.testcase.id")) {
                    missingIds.add("TestCaseId");
                }
                if (!testResult.getMetadata().containsKey("ado.testplan.id")) {
                    missingIds.add("TestPlanId");
                }
                if (!testResult.getMetadata().containsKey("ado.testsuite.id")) {
                    missingIds.add("TestSuiteId");
                }
                if (!missingIds.isEmpty()) {
                    logger.debug("Skipping ADO publish for test '{}' - Missing IDs: {}", 
                        testResult.getTestName(), String.join(", ", missingIds));
                }
            }
            
            // Add test result to report
            CSReportManager.getInstance().addTestResult(testResult);
            
            // Clear test context
            CSReportManager.clearCurrentTestContext();
            
            // Track test completion
            int completed = completedTests.incrementAndGet();
            logger.info("[{}] Test completed. Total completed: {}/{}", threadName, completed, totalExpectedTests);
            
            // Note: Final cleanup will be handled by @AfterSuite and shutdown hook
            // This ensures all browsers are properly closed even if tests fail
        }
    }
    
    /**
     * Check if feature should be included based on feature-level tags
     */
    private boolean shouldIncludeFeature(CSFeatureFile feature) {
        // If no tags specified, include the feature
        if ((tagsToRun == null || tagsToRun.trim().isEmpty()) && 
            (tagsToExclude == null || tagsToExclude.trim().isEmpty())) {
            return true;
        }
        
        Set<String> includeTags = tagsToRun != null && !tagsToRun.trim().isEmpty() 
            ? new HashSet<>(Arrays.asList(tagsToRun.split(",")))
            : new HashSet<>();
        Set<String> excludeTags = tagsToExclude != null && !tagsToExclude.trim().isEmpty() 
            ? new HashSet<>(Arrays.asList(tagsToExclude.split(",")))
            : new HashSet<>();
        
        List<String> featureTags = feature.getTags();
        
        // Check exclude tags first
        for (String tag : featureTags) {
            if (excludeTags.contains(tag)) {
                return false;
            }
        }
        
        // If no include tags specified, feature is included (unless excluded)
        if (includeTags.isEmpty()) {
            return true;
        }
        
        // Check include tags
        for (String tag : featureTags) {
            if (includeTags.contains(tag)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Filter scenarios by tags
     */
    private List<CSFeatureFile.Scenario> filterScenariosByTags(List<CSFeatureFile.Scenario> scenarios) {
        // If no tags specified, include all scenarios
        if ((tagsToRun == null || tagsToRun.trim().isEmpty()) && 
            (tagsToExclude == null || tagsToExclude.trim().isEmpty())) {
            logger.info("No tag filters specified, including all {} scenarios", scenarios.size());
            return scenarios;
        }
        
        Set<String> includeTags = tagsToRun != null && !tagsToRun.trim().isEmpty() 
            ? new HashSet<>(Arrays.asList(tagsToRun.split(",")))
            : new HashSet<>();
        Set<String> excludeTags = tagsToExclude != null && !tagsToExclude.trim().isEmpty() 
            ? new HashSet<>(Arrays.asList(tagsToExclude.split(",")))
            : new HashSet<>();
        
        logger.info("Filtering scenarios with include tags: {} and exclude tags: {}", includeTags, excludeTags);
        
        return scenarios.stream()
            .filter(scenario -> {
                List<String> scenarioTags = scenario.getTags();
                logger.debug("Scenario '{}' has tags: {}", scenario.getName(), scenarioTags);
                
                // Check exclude tags first
                for (String tag : scenarioTags) {
                    if (excludeTags.contains(tag)) {
                        return false;
                    }
                }
                
                // Check include tags
                if (!includeTags.isEmpty()) {
                    for (String tag : scenarioTags) {
                        if (includeTags.contains(tag)) {
                            return true;
                        }
                    }
                    return false;
                }
                
                return true;
            })
            .collect(Collectors.toList());
    }
    
    /**
     * Alternative runner for specific feature file
     */
    @Test(enabled = false)
    @Parameters({"featureFile"})
    public void runSpecificFeature(@org.testng.annotations.Optional("") String featureFile) {
        if (featureFile.isEmpty()) {
            return;
        }
        
        logger.info("Running specific feature: {}", featureFile);
        scenarioRunner.runFeatureFile(featureFile);
    }
    
    /**
     * Create a deep copy of a scenario to ensure thread safety
     */
    private CSFeatureFile.Scenario createScenarioCopy(CSFeatureFile.Scenario original) {
        CSFeatureFile.Scenario copy = new CSFeatureFile.Scenario();
        copy.setName(original.getName());
        copy.setDescription(original.getDescription());
        copy.setTags(new ArrayList<>(original.getTags()));
        copy.setOutline(original.isOutline());
        copy.setExamplesConfig(original.getExamplesConfig());
        
        // Deep copy the data row
        if (original.getDataRow() != null) {
            Map<String, String> dataRowCopy = new HashMap<>();
            dataRowCopy.putAll(original.getDataRow());
            copy.setDataRow(dataRowCopy);
        }
        
        // Deep copy steps
        List<CSFeatureFile.Step> stepsCopy = new ArrayList<>();
        for (CSFeatureFile.Step step : original.getSteps()) {
            CSFeatureFile.Step stepCopy = new CSFeatureFile.Step();
            stepCopy.setKeyword(step.getKeyword());
            stepCopy.setText(step.getText());
            stepCopy.setLineNumber(step.getLineNumber());
            
            // Copy data table if present
            if (step.getDataTable() != null) {
                List<List<String>> tableCopy = new ArrayList<>();
                for (List<String> row : step.getDataTable()) {
                    tableCopy.add(new ArrayList<>(row));
                }
                stepCopy.setDataTable(tableCopy);
            }
            
            // Copy doc string if present
            if (step.getDocString() != null) {
                stepCopy.setDocString(step.getDocString());
            }
            
            stepsCopy.add(stepCopy);
        }
        copy.setSteps(stepsCopy);
        
        return copy;
    }
    
    /**
     * Alternative runner for all features with specific tag
     */
    @Test(enabled = false)
    @Parameters({"tag"})
    public void runFeaturesWithTag(@org.testng.annotations.Optional("") String tag) {
        if (tag.isEmpty()) {
            return;
        }
        
        logger.info("Running features with tag: {}", tag);
        
        for (String featureFile : featureFiles) {
            try {
                CSFeatureFile feature = featureParser.parseFeatureFile(featureFile);
                
                for (CSFeatureFile.Scenario scenario : feature.getScenarios()) {
                    if (scenario.getTags().contains(tag)) {
                        scenarioRunner.runScenarioFromFile(featureFile, feature, scenario);
                    }
                }
                
            } catch (Exception e) {
                logger.error("Error running feature: {}", featureFile, e);
            }
        }
    }
    
    /**
     * Ensure complete isolation between scenarios
     */
    private void ensureScenarioIsolation(String threadName, String featureFile, String featureName, String scenarioName) {
        logger.debug("[{}] Ensuring isolation for scenario '{}' from feature '{}' ({})", 
            threadName, scenarioName, featureName, featureFile);
        
        // Clear any thread-local state that might leak between scenarios
        // This is especially important when running multiple feature files
        CSStepDefinitions.clearThreadLocalState();
        
        // Log current isolation state
        logger.debug("[ISOLATION] Current feature scenario map: {}", featureScenarioMap);
    }
    
    /**
     * Get stack trace as string
     */
    private String getStackTrace(Throwable throwable) {
        if (throwable == null) {
            return null;
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append(throwable.toString()).append("\n");
        for (StackTraceElement element : throwable.getStackTrace()) {
            sb.append("\tat ").append(element.toString()).append("\n");
        }
        
        // Include cause if present
        Throwable cause = throwable.getCause();
        if (cause != null) {
            sb.append("Caused by: ").append(getStackTrace(cause));
        }
        
        return sb.toString();
    }
    
    /**
     * Initialize Azure DevOps integration if enabled
     */
    private void initializeADOIfEnabled() {
        try {
            // Check if ADO is enabled in configuration or suite parameters
            String adoEnabled = config.getProperty("cs.azure.devops.enabled", "false");
            
            // Suite parameter takes priority over application.properties
            if (suiteAdoEnabled != null && !suiteAdoEnabled.isEmpty()) {
                adoEnabled = suiteAdoEnabled;
                logger.debug("Using cs.azure.devops.enabled from suite parameter: {}", adoEnabled);
            }
            
            if ("true".equalsIgnoreCase(adoEnabled)) {
                logger.info("Azure DevOps integration is enabled");
                
                // Get ADO publisher instance but DON'T start a test run yet
                // We'll start it only when we find a test with complete ADO mapping
                adoPublisher = CSAzureDevOpsPublisher.getInstance();
                
                if (adoPublisher.isEnabled()) {
                    logger.info("Azure DevOps publisher initialized - test run will be created when tests with complete ADO mapping are found");
                }
            } else {
                logger.debug("Azure DevOps integration is disabled");
            }
        } catch (Exception e) {
            logger.warn("Failed to initialize Azure DevOps integration: {}", e.getMessage());
            // Don't fail test execution if ADO initialization fails
        }
    }
    
    /**
     * Collect test points and create test run with those points
     */
    private void collectTestPointsAndCreateTestRun(List<Object[]> testData) {
        Set<Integer> testPointIds = new HashSet<>();
        
        for (Object[] test : testData) {
            String featureFile = (String) test[0];
            CSFeatureFile feature = (CSFeatureFile) test[1];
            CSFeatureFile.Scenario scenario = (CSFeatureFile.Scenario) test[2];
            
            CSADOTagExtractor.ADOMetadata metadata = extractADOMetadataFromScenario(feature, scenario);
            
            if (metadata != null && 
                metadata.hasTestCaseMapping() && 
                metadata.getTestPlanId() != null && 
                metadata.getTestSuiteId() != null) {
                
                // Get test point IDs for all test cases
                for (Integer testCaseId : metadata.getTestCaseIds()) {
                    Integer testPointId = adoPublisher.getTestPointId(
                        metadata.getTestPlanId(),
                        metadata.getTestSuiteId(),
                        testCaseId
                    );
                    
                    if (testPointId != null) {
                        testPointIds.add(testPointId);
                        logger.info("Collected test point {} for test case {}", testPointId, testCaseId);
                    }
                }
            }
        }
        
        // Create test run with collected test points
        if (!testPointIds.isEmpty()) {
            try {
                // Use suite name if available, otherwise default to "CS BDD Test Run"
                String baseName = (suiteName != null && !suiteName.trim().isEmpty()) 
                    ? suiteName 
                    : "CS BDD Test Run";
                String runName = baseName + " - Test Run - " + 
                    LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
                
                List<Integer> pointIdList = new ArrayList<>(testPointIds);
                adoPublisher.startTestRunWithPoints(runName, pointIdList);
                logger.info("Started Azure DevOps test run with {} test points: {}", pointIdList.size(), pointIdList);
                adoTestRunStarted = true;
                adoTestPointIds = testPointIds;
            } catch (Exception e) {
                logger.error("Failed to start ADO test run with test points", e);
            }
        } else {
            logger.info("No test points found for ADO test run");
        }
    }
    
    /**
     * Extract ADO metadata from scenario and feature tags
     * Hierarchy: Feature/Scenario Tags > Suite XML > Properties File
     * TestCaseId MUST be in scenario tags, otherwise skip ADO integration
     */
    private CSADOTagExtractor.ADOMetadata extractADOMetadataFromScenario(
            CSFeatureFile feature, CSFeatureFile.Scenario scenario) {
        
        CSADOTagExtractor.ADOMetadata metadata = new CSADOTagExtractor.ADOMetadata();
        
        // FIRST: Extract test case IDs from scenario tags (REQUIRED for ADO integration)
        // Support multiple formats:
        // - @ADO-TestCase:419
        // - @TestCaseId:420
        // - @ADO-TestCase:419,420,421
        // - @TestCaseId:{23232,42323}
        // - @ADO-TestCase:{TC-001,TC-002,TC-003}
        boolean hasTestCaseId = false;
        for (String tag : scenario.getTags()) {
            // Check for TestCase patterns
            if (tag.contains("TestCase") || tag.contains("TestCaseId")) {
                String idsPart = null;
                
                // Extract the IDs part after the colon
                if (tag.contains(":")) {
                    idsPart = tag.substring(tag.indexOf(':') + 1);
                    
                    // Remove curly braces if present
                    idsPart = idsPart.replace("{", "").replace("}", "");
                    
                    // Remove any prefixes like TC- or TC_
                    idsPart = idsPart.replaceAll("TC[-_]?", "");
                    
                    // Split by comma to get individual IDs
                    String[] ids = idsPart.split(",");
                    for (String id : ids) {
                        try {
                            metadata.addTestCaseId(Integer.parseInt(id.trim()));
                            hasTestCaseId = true;
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid test case ID in tag '{}': {}", tag, id);
                        }
                    }
                    logger.debug("Found Test Case IDs in scenario tag '{}': {}", tag, metadata.getTestCaseIds());
                }
            } else {
                // Fallback to regex pattern for other formats
                Matcher caseMatcher = TEST_CASE_PATTERN.matcher(tag);
                if (caseMatcher.find()) {
                    metadata.addTestCaseId(Integer.parseInt(caseMatcher.group(1)));
                    hasTestCaseId = true;
                    logger.debug("Found Test Case ID in scenario tag: {}", caseMatcher.group(1));
                }
            }
        }
        
        // If no TestCaseId found, skip ADO integration for this scenario
        if (!hasTestCaseId) {
            logger.debug("No TestCaseId found in scenario '{}' - skipping ADO integration", scenario.getName());
            return null;
        }
        
        // HIERARCHY FOR TEST PLAN ID:
        // 1. First priority: Scenario tags
        for (String tag : scenario.getTags()) {
            Matcher planMatcher = TEST_PLAN_PATTERN.matcher(tag);
            if (planMatcher.find()) {
                metadata.setTestPlanId(Integer.parseInt(planMatcher.group(1)));
                logger.debug("Using Test Plan ID from scenario tag: {}", metadata.getTestPlanId());
                break;
            }
        }
        
        // 2. Second priority: Feature tags
        if (metadata.getTestPlanId() == null) {
            for (String tag : feature.getTags()) {
                Matcher planMatcher = TEST_PLAN_PATTERN.matcher(tag);
                if (planMatcher.find()) {
                    metadata.setTestPlanId(Integer.parseInt(planMatcher.group(1)));
                    logger.debug("Using Test Plan ID from feature tag: {}", metadata.getTestPlanId());
                    break;
                }
            }
        }
        
        // 3. Third priority: Suite XML parameter (optional)
        if (metadata.getTestPlanId() == null && suiteXmlTestPlanId != null && !suiteXmlTestPlanId.isEmpty()) {
            try {
                metadata.setTestPlanId(Integer.parseInt(suiteXmlTestPlanId));
                logger.debug("Using Test Plan ID from suite XML: {}", suiteXmlTestPlanId);
            } catch (NumberFormatException e) {
                logger.warn("Invalid test plan ID in suite XML: {}", suiteXmlTestPlanId);
            }
        }
        
        // 4. Fourth priority: Properties file
        if (metadata.getTestPlanId() == null) {
            String planId = config.getProperty("cs.azure.devops.test.plan.id");
            if (planId != null && !planId.isEmpty()) {
                try {
                    metadata.setTestPlanId(Integer.parseInt(planId));
                    logger.debug("Using Test Plan ID from properties: {}", planId);
                } catch (NumberFormatException e) {
                    logger.debug("Invalid test plan ID in properties: {}", planId);
                }
            }
        }
        
        // HIERARCHY FOR TEST SUITE ID:
        // 1. First priority: Scenario tags
        for (String tag : scenario.getTags()) {
            Matcher suiteMatcher = TEST_SUITE_PATTERN.matcher(tag);
            if (suiteMatcher.find()) {
                metadata.setTestSuiteId(Integer.parseInt(suiteMatcher.group(1)));
                logger.debug("Using Test Suite ID from scenario tag: {}", metadata.getTestSuiteId());
                break;
            }
        }
        
        // 2. Second priority: Feature tags
        if (metadata.getTestSuiteId() == null) {
            for (String tag : feature.getTags()) {
                Matcher suiteMatcher = TEST_SUITE_PATTERN.matcher(tag);
                if (suiteMatcher.find()) {
                    metadata.setTestSuiteId(Integer.parseInt(suiteMatcher.group(1)));
                    logger.debug("Using Test Suite ID from feature tag: {}", metadata.getTestSuiteId());
                    break;
                }
            }
        }
        
        // 3. Third priority: Suite XML parameter (optional)
        if (metadata.getTestSuiteId() == null && suiteXmlTestSuiteId != null && !suiteXmlTestSuiteId.isEmpty()) {
            try {
                metadata.setTestSuiteId(Integer.parseInt(suiteXmlTestSuiteId));
                logger.debug("Using Test Suite ID from suite XML: {}", suiteXmlTestSuiteId);
            } catch (NumberFormatException e) {
                logger.warn("Invalid test suite ID in suite XML: {}", suiteXmlTestSuiteId);
            }
        }
        
        // 4. Fourth priority: Properties file
        if (metadata.getTestSuiteId() == null) {
            String suiteId = config.getProperty("cs.azure.devops.test.suite.id");
            if (suiteId != null && !suiteId.isEmpty()) {
                try {
                    metadata.setTestSuiteId(Integer.parseInt(suiteId));
                    logger.debug("Using Test Suite ID from properties: {}", suiteId);
                } catch (NumberFormatException e) {
                    logger.debug("Invalid test suite ID in properties: {}", suiteId);
                }
            }
        }
        
        // Log final values being used
        if (metadata.getTestPlanId() != null || metadata.getTestSuiteId() != null) {
            logger.info("ADO Metadata - Test Plan: {}, Test Suite: {}, Test Case: {}",
                metadata.getTestPlanId(), metadata.getTestSuiteId(), metadata.getTestCaseId());
        }
        
        return metadata;
    }
    
    /**
     * Extract ADO IDs from a single tag
     */
    private void extractFromTag(String tag, CSADOTagExtractor.ADOMetadata metadata) {
        // Test Case ID
        Matcher testCaseMatcher = TEST_CASE_PATTERN.matcher(tag);
        if (testCaseMatcher.find() && metadata.getTestCaseId() == null) {
            metadata.setTestCaseId(Integer.parseInt(testCaseMatcher.group(1)));
        }
        
        // Test Plan ID
        Matcher testPlanMatcher = TEST_PLAN_PATTERN.matcher(tag);
        if (testPlanMatcher.find() && metadata.getTestPlanId() == null) {
            metadata.setTestPlanId(Integer.parseInt(testPlanMatcher.group(1)));
        }
        
        // Test Suite ID
        Matcher testSuiteMatcher = TEST_SUITE_PATTERN.matcher(tag);
        if (testSuiteMatcher.find() && metadata.getTestSuiteId() == null) {
            metadata.setTestSuiteId(Integer.parseInt(testSuiteMatcher.group(1)));
        }
    }
    
    /**
     * Check if a class is available on the classpath
     */
    private boolean isClassAvailable(String className) {
        try {
            Class.forName(className);
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }
}