package com.testforge.cs.bdd;

import com.testforge.cs.annotations.CSDataRow;
import com.testforge.cs.security.CSEncryptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Represents a step definition with pattern matching and method binding
 */
public class CSStepDefinition {
    private static final Logger logger = LoggerFactory.getLogger(CSStepDefinition.class);
    
    private final Pattern pattern;
    private final Method method;
    private final Object instance;
    private final Class<?> stepClass; // CRITICAL FIX: Store step class for thread-local lookup
    private final StepType stepType;
    private final String originalPattern;
    
    public enum StepType {
        GIVEN, WHEN, THEN, AND, BUT, ANY
    }
    
    public CSStepDefinition(String pattern, Method method, Object instance, StepType stepType) {
        this.originalPattern = pattern;
        this.pattern = compilePattern(pattern);
        this.method = method;
        this.instance = instance;
        this.stepClass = instance.getClass(); // Store for thread-local lookup
        this.stepType = stepType;
    }
    
    /**
     * Compile the step pattern with parameter placeholders
     */
    private Pattern compilePattern(String pattern) {
        // If pattern already contains regex symbols, use it as-is (legacy support)
        if (pattern.contains("^") || pattern.contains("$") || pattern.contains("\\")) {
            return Pattern.compile(pattern);
        }
        
        // Convert placeholder-based pattern to regex
        String regex = pattern;
        
        // First, escape special regex characters (except our placeholders)
        regex = regex.replaceAll("([\\[\\]().*+?])", "\\\\$1");
        
        // Replace placeholders with regex groups
        // Support both quoted and unquoted parameters
        regex = regex
            .replaceAll("\\{string\\}", "\"([^\"]*)\"")      // Match quoted strings
            .replaceAll("\\{int\\}", "(\\d+)")                // Match integers
            .replaceAll("\\{float\\}", "(\\d+\\.\\d+)")       // Match floats
            .replaceAll("\\{number\\}", "(\\d+(?:\\.\\d+)?)")// Match int or float
            .replaceAll("\\{word\\}", "(\\w+)")               // Match single words
            .replaceAll("\\{(\\w+)\\}", "(?:\"([^\"]*)\"|([^\\s]+))"); // Named parameters - match quoted or unquoted
        
        return Pattern.compile("^" + regex + "$");
    }
    
    /**
     * Check if the step text matches this definition
     */
    public boolean matches(String stepText) {
        return pattern.matcher(stepText).matches();
    }
    
    /**
     * Extract parameters from step text
     */
    public Object[] extractParameters(String stepText) {
        var matcher = pattern.matcher(stepText);
        if (!matcher.matches()) {
            return new Object[0];
        }
        
        // Count actual non-null groups (for named parameters with alternation)
        List<Object> extractedParams = new ArrayList<>();
        Class<?>[] paramTypes = method.getParameterTypes();
        int paramIndex = 0;
        
        for (int i = 1; i <= matcher.groupCount(); i++) {
            String value = matcher.group(i);
            if (value != null) {
                // Skip if this is part of an alternation group and we already have a value
                if (i > 1 && matcher.group(i-1) != null && 
                    originalPattern.contains("{") && !originalPattern.contains("^")) {
                    continue;
                }
                
                if (paramIndex < paramTypes.length) {
                    extractedParams.add(convertParameter(value, paramTypes[paramIndex]));
                } else {
                    extractedParams.add(value);
                }
                paramIndex++;
            }
        }
        
        return extractedParams.toArray();
    }
    
    /**
     * Extract parameters with context support for data row injection
     */
    public Object[] extractParametersWithContext(String stepText, Map<String, Object> context) {
        var matcher = pattern.matcher(stepText);
        if (!matcher.matches()) {
            return new Object[0];
        }
        
        Parameter[] methodParams = method.getParameters();
        List<Object> extractedParams = new ArrayList<>();
        
        // First, extract all text parameters from regex groups
        List<String> textParameters = new ArrayList<>();
        for (int i = 1; i <= matcher.groupCount(); i++) {
            String value = matcher.group(i);
            if (value != null) {
                textParameters.add(value);
            }
        }
        
        int textParamIndex = 0; // Track position in textParameters list
        
        // Process each method parameter
        for (int i = 0; i < methodParams.length; i++) {
            Parameter param = methodParams[i];
            
            // Check if this parameter should receive the data row
            if (param.isAnnotationPresent(CSDataRow.class)) {
                CSDataRow dataRowAnnotation = param.getAnnotation(CSDataRow.class);
                Object dataRow = context.get("dataRow");
                
                if (dataRow instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, String> fullDataRow = (Map<String, String>) dataRow;
                    
                    // Filter metadata if requested
                    if (!dataRowAnnotation.includeMetadata()) {
                        Map<String, String> filteredData = new HashMap<>();
                        for (Map.Entry<String, String> entry : fullDataRow.entrySet()) {
                            String key = entry.getKey();
                            // Skip metadata fields
                            if (!key.equals("dataSourceType") && 
                                !key.equals("dataSourceFile") && 
                                !key.equals("browser") && 
                                !key.equals("environment")) {
                                filteredData.put(key, entry.getValue());
                            }
                        }
                        extractedParams.add(filteredData);
                    } else {
                        extractedParams.add(fullDataRow);
                    }
                } else {
                    // No data row available, pass empty map
                    extractedParams.add(new HashMap<String, String>());
                }
            } else {
                // Regular parameter from step text
                if (textParamIndex < textParameters.size()) {
                    String value = textParameters.get(textParamIndex);
                    extractedParams.add(convertParameter(value, param.getType()));
                    textParamIndex++;
                } else {
                    // This shouldn't happen if step pattern is correct, but handle gracefully
                    throw new IllegalArgumentException(
                        "Step pattern mismatch: Expected " + (methodParams.length - countDataRowParams(methodParams)) + 
                        " text parameters but found " + textParameters.size() + " for step: " + stepText
                    );
                }
            }
        }
        
        return extractedParams.toArray();
    }
    
    /**
     * Count parameters annotated with @CSDataRow
     */
    private int countDataRowParams(Parameter[] parameters) {
        int count = 0;
        for (Parameter param : parameters) {
            if (param.isAnnotationPresent(CSDataRow.class)) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Convert string parameter to the appropriate type
     * Automatically decrypts encrypted values (wrapped in ENC())
     */
    private Object convertParameter(String value, Class<?> type) {
        // First check if the value is encrypted and decrypt it
        if (CSEncryptionUtils.isEncrypted(value)) {
            value = CSEncryptionUtils.decrypt(value);
        }
        
        // Then convert to the appropriate type
        if (type == String.class) {
            return value;
        } else if (type == Integer.class || type == int.class) {
            return Integer.parseInt(value);
        } else if (type == Long.class || type == long.class) {
            return Long.parseLong(value);
        } else if (type == Double.class || type == double.class) {
            return Double.parseDouble(value);
        } else if (type == Float.class || type == float.class) {
            return Float.parseFloat(value);
        } else if (type == Boolean.class || type == boolean.class) {
            return Boolean.parseBoolean(value);
        }
        return value;
    }
    
    /**
     * Execute the step with given parameters
     * Automatically injects page objects before execution for convenience
     */
    public void execute(Object[] parameters) throws Exception {
        // CRITICAL FIX: Get thread-local step instance for perfect thread isolation
        // This ensures each thread has its own step instance with its own page object fields
        Object threadLocalInstance = getThreadLocalInstance();
        
        // AUTOMATIC PAGE OBJECT INJECTION
        // Inject page objects into the thread-local step instance before execution
        // This enables users to simply declare: private LoginPage loginPage;
        // Framework handles thread-safe initialization automatically
        injectPageObjects(threadLocalInstance);
        
        // Set test context before step execution to enable CSReportManager.info/fail/pass/warn
        setTestContextForReporting();
        
        method.setAccessible(true);
        method.invoke(threadLocalInstance, parameters);
    }
    
    /**
     * Set test context for step reporting to enable CSReportManager methods
     */
    private void setTestContextForReporting() {
        try {
            // Get current scenario runner instance
            Class<?> runnerClass = Class.forName("com.testforge.cs.bdd.CSScenarioRunner");
            Object runner = runnerClass.getMethod("getCurrentInstance").invoke(null);
            
            if (runner != null) {
                // Get current test result
                java.lang.reflect.Method getTestResultMethod = runnerClass.getMethod("getCurrentTestResult");
                Object testResult = getTestResultMethod.invoke(runner);
                
                if (testResult != null) {
                    // Get test ID from result
                    java.lang.reflect.Method getTestIdMethod = testResult.getClass().getMethod("getTestId");
                    String testId = (String) getTestIdMethod.invoke(testResult);
                    
                    // Set current test context in report manager
                    Class<?> reportManagerClass = Class.forName("com.testforge.cs.reporting.CSReportManager");
                    java.lang.reflect.Method setContextMethod = reportManagerClass.getMethod("setCurrentTestContext", String.class);
                    setContextMethod.invoke(null, testId);
                    
                    logger.debug("Set test context for reporting: {}", testId);
                }
            }
        } catch (Exception e) {
            logger.debug("Could not set test context for reporting: {}", e.getMessage());
        }
    }
    
    /**
     * Get thread-local step instance for perfect thread isolation
     */
    private Object getThreadLocalInstance() {
        try {
            // Get CSStepRegistry instance and get thread-local step instance
            Class<?> registryClass = Class.forName("com.testforge.cs.bdd.CSStepRegistry");
            Object registryInstance = registryClass.getMethod("getInstance").invoke(null);
            java.lang.reflect.Method getInstanceMethod = registryClass.getMethod("getThreadLocalStepInstance", Class.class);
            return getInstanceMethod.invoke(registryInstance, stepClass);
        } catch (Exception e) {
            // Fall back to shared instance if thread-local lookup fails
            logger.debug("Failed to get thread-local instance, using shared instance: {}", e.getMessage());
            return instance;
        }
    }
    
    /**
     * Inject page objects into the step instance.
     * This method is called before each step execution to ensure:
     * 1. Fresh page instances for each thread (thread safety)
     * 2. Lazy initialization (pages created only when used)
     * 3. Zero boilerplate for users (just declare fields)
     */
    private void injectPageObjects(Object stepInstance) {
        try {
            // Use reflection-safe approach to avoid hard dependency
            // This allows the framework to work even if CSPageInjector is not available
            Class<?> injectorClass = Class.forName("com.testforge.cs.injection.CSPageInjector");
            java.lang.reflect.Method injectMethod = injectorClass.getMethod("injectPageObjects", Object.class);
            injectMethod.invoke(null, stepInstance);
        } catch (ClassNotFoundException e) {
            // CSPageInjector not available - skip injection silently
            // This maintains backward compatibility
        } catch (Exception e) {
            // Log error but don't fail the step execution
            // Page injection is a convenience feature, not critical
            logger.debug("Page injection failed (non-critical): {}", e.getMessage());
        }
    }
    
    // Getters
    public Pattern getPattern() {
        return pattern;
    }
    
    public Method getMethod() {
        return method;
    }
    
    public Object getInstance() {
        return instance;
    }
    
    public StepType getStepType() {
        return stepType;
    }
    
    public String getOriginalPattern() {
        return originalPattern;
    }
    
    @Override
    public String toString() {
        return String.format("%s: %s -> %s.%s", 
            stepType, originalPattern, 
            instance.getClass().getSimpleName(), 
            method.getName());
    }
}