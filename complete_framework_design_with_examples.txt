# CS Framework - Complete Design Document for Development (Updated Version)

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Framework Vision & Objectives](#framework-vision--objectives)
3. [Architecture Overview](#architecture-overview)
4. [Core Framework Design](#core-framework-design)
5. [Driver Management System](#driver-management-system)
6. [Element Framework Design](#element-framework-design)
7. [Page Object Model Implementation](#page-object-model-implementation)
8. [BDD Integration & Enhanced Features](#bdd-integration--enhanced-features)
9. [Configuration Management System](#configuration-management-system)
10. [Secret Management & Encryption](#secret-management--encryption)
11. [Data Management Layer](#data-management-layer)
12. [Reporting System](#reporting-system)
13. [Test Execution Engine](#test-execution-engine)
14. [Parallel Execution Architecture](#parallel-execution-architecture)
15. [Azure DevOps Integration](#azure-devops-integration)
16. [API Testing Framework](#api-testing-framework)
17. [Database Testing Support](#database-testing-support)
18. [Intelligence & Self-Healing](#intelligence--self-healing)
19. [Logging & Monitoring](#logging--monitoring)
20. [Exception Handling Strategy](#exception-handling-strategy)
21. [Framework Packaging & Distribution](#framework-packaging--distribution)
22. [Implementation Roadmap](#implementation-roadmap)
23. [Complete Usage Examples](#complete-usage-examples)
24. [Framework Utilities](#framework-utilities)

---

## 1. Executive Summary

The CS Framework is an enterprise-grade, intelligent test automation framework designed to provide a unified solution for web UI, API, and database testing. Built on Java, it will be distributed as a Maven dependency that users can easily integrate into their projects. The framework abstracts all Selenium complexities and provides enhanced features like AI-powered self-healing, simplified secret management, and zero-configuration execution.

### Key Differentiators
- **Maven Dependency Distribution**: Easy integration as a library
- **No Direct Selenium Exposure**: All interactions through framework abstractions
- **Azure DevOps Integration**: Native support for test result synchronization
- **Unified BDD Experience**: Single annotation for all Gherkin keywords
- **Automatic Secret Management**: Simple ENC() prefix for encrypted values
- **Self-Refreshing Elements**: No stale element exceptions
- **Comprehensive API Testing**: Native Java HTTP client with API chaining
- **Database Validation**: Built-in database testing support with named databases
- **SQL Query Management**: Centralized SQL queries in properties files
- **Enhanced Locator Support**: Alternative locators can reference object repository keys
- **Comprehensive Utilities**: Extensive utility classes for file, Excel, CSV, JSON, database, and string operations

### Exclusions (Phase 1)
- Mobile testing (Appium) - to be added in future phases
- Cloud provider integrations (BrowserStack, SauceLabs) - future enhancement
- CI/CD integrations other than Azure DevOps - future enhancement

---

## 2. Framework Vision & Objectives

### Vision
Create a framework that completely abstracts Selenium complexity while providing powerful features through simple APIs, distributed as a Maven dependency for easy adoption.

### Primary Objectives
1. **Complete Selenium Abstraction**: Users never interact with WebDriver/WebElement directly
2. **Maven Distribution**: Package as a library for easy integration
3. **Resource Management**: Handle resources properly when packaged as JAR
4. **Azure DevOps Native**: Built-in support for ADO test management
5. **API & DB Testing**: Comprehensive support beyond UI testing
6. **Centralized Configuration**: Support for SQL queries, object repository, and test data in properties files
7. **Rich Utilities**: Provide extensive utility classes for common operations

### Design Principles
- **No Selenium Exposure**: All Selenium classes wrapped by framework classes
- **Resource-Aware**: Configuration and resources work from JAR packaging
- **Proxy Support**: Full proxy configuration for enterprise environments
- **Extensible**: Users can extend framework capabilities
- **Self-Contained**: Minimal external dependencies
- **Configuration-Driven**: Support for external configuration files

---

## 3. Architecture Overview

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                          User Test Layer                              │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌──────────────┐│
│  │ BDD Features│  │TestNG Tests │  │ API Tests  │  │ DB Tests     ││
│  └─────────────┘  └─────────────┘  └────────────┘  └──────────────┘│
└──────────────────────────────┬──────────────────────────────────────┘
                               │
┌──────────────────────────────▼──────────────────────────────────────┐
│                    CS Framework (Maven JAR)                          │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │ CSFrameworkRunner (Automatic initialization & configuration)   │ │
│  └────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
┌──────────────────────────────▼──────────────────────────────────────┐
│                      Core Framework Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌─────────────┐│
│  │CSFramework  │  │  CSContext  │  │CSConfig    │  │CSSession    ││
│  │(Singleton)  │  │(ThreadLocal)│  │(Hierarchy) │  │(Manager)    ││
│  └─────────────┘  └─────────────┘  └────────────┘  └─────────────┘│
└──────────────────────────────┬──────────────────────────────────────┘
                               │
┌──────────────────────────────▼──────────────────────────────────────┐
│                     Feature Modules Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌─────────────┐│
│  │Driver Mgmt  │  │Element      │  │Page Object │  │Data Layer   ││
│  │- CSDriver   │  │- CSElement  │  │- CSBasePage│  │- Excel/CSV  ││
│  │- Browser    │  │- Smart Wait │  │- Factory   │  │- Database   ││
│  │- Proxy      │  │- Self-Heal  │  │- Refresh   │  │- API/JSON   ││
│  └─────────────┘  └─────────────┘  └────────────┘  └─────────────┘│
│                                                                      │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌─────────────┐│
│  │BDD Engine   │  │Report Engine│  │API Testing │  │Intelligence ││
│  │- Unified    │  │- Multi-fmt  │  │- Native    │  │- Self-Heal  ││
│  │- @CSBDDStep │  │- Custom Log │  │- Chaining  │  │- AI Locate  ││
│  └─────────────┘  └─────────────┘  └────────────┘  └─────────────┘│
│                                                                      │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌─────────────┐│
│  │Utilities    │  │SQL Manager  │  │Config Mgmt │  │Repository   ││
│  │- File Utils │  │- Query Props│  │- Props Files│ │- Object Repo││
│  │- Excel/CSV  │  │- Named DBs  │  │- Env Config│  │- Locator Map││
│  │- JSON/XML   │  │- Query Keys │  │- Secrets   │  │- Dynamic    ││
│  └─────────────┘  └─────────────┘  └────────────┘  └─────────────┘│
└──────────────────────────────┬──────────────────────────────────────┘
                               │
┌──────────────────────────────▼──────────────────────────────────────┐
│                    Infrastructure Layer                              │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌─────────────┐│
│  │Secret Mgmt  │  │Logging      │  │Exception   │  │Azure DevOps ││
│  │- Simple     │  │- Structured │  │- Handling  │  │- Test Sync  ││
│  │- Auto       │  │- Context    │  │- Recovery  │  │- Results    ││
│  └─────────────┘  └─────────────┘  └────────────┘  └─────────────┘│
└─────────────────────────────────────────────────────────────────────┘
```

### Framework Abstraction Layer

```
User Code                    Framework Layer              Selenium Layer
─────────                    ───────────────              ──────────────
CSDriver         ──────►     CSDriverImpl      ──────►    WebDriver
CSElement        ──────►     CSElementImpl     ──────►    WebElement
CSActions        ──────►     CSActionsImpl     ──────►    Actions
CSJavaScript     ──────►     CSJavaScriptImpl  ──────►    JavascriptExecutor
CSSelect         ──────►     CSSelectImpl      ──────►    Select
```

---

## 4. Core Framework Design

### 4.1 CSFramework (Main Controller)

```java
public class CSFramework {
    private static volatile CSFramework instance;
    private static final AtomicBoolean initialized = new AtomicBoolean(false);
    
    // Core Components - No direct Selenium exposure
    private final ConfigurationManager configManager;
    private final CSDriverManager driverManager;
    private final CSDataSourceManager dataSourceManager;
    private final CSParallelEngine parallelEngine;
    private final CSReportEngine reportEngine;
    private final CSSessionManager sessionManager;
    private final CSSqlQueryManager sqlQueryManager;
    private final CSObjectRepository objectRepository;
    private final CSContext context;
    private final CSConfiguration configuration;
    private final CSAzureDevOpsIntegration adoIntegration;
    
    // Framework State
    private final Map<String, Object> globalState = new ConcurrentHashMap<>();
    private final List<FrameworkListener> listeners = new CopyOnWriteArrayList<>();
    
    private CSFramework() {
        this.configuration = CSConfiguration.getInstance();
        this.configManager = ConfigurationManager.getInstance();
        this.reportEngine = CSReportEngine.getInstance();
        this.driverManager = CSDriverManager.getInstance();
        this.context = new CSContext();
        this.dataSourceManager = CSDataSourceManager.getInstance();
        this.parallelEngine = CSParallelEngine.getInstance();
        this.sessionManager = CSSessionManager.getInstance();
        this.sqlQueryManager = CSSqlQueryManager.getInstance();
        this.objectRepository = CSObjectRepository.getInstance();
        
        // Initialize ADO integration if enabled
        if (configuration.getBoolean("cs.ado.enabled", false)) {
            this.adoIntegration = new CSAzureDevOpsIntegration();
        } else {
            this.adoIntegration = null;
        }
    }
    
    public static CSFramework getInstance() {
        if (instance == null) {
            synchronized (CSFramework.class) {
                if (instance == null) {
                    instance = new CSFramework();
                }
            }
        }
        return instance;
    }
    
    public synchronized void initialize() {
        if (initialized.get()) {
            logger.debug("Framework already initialized");
            return;
        }
        
        try {
            logger.info("Initializing CS Framework...");
            
            // 1. Configuration first (handles JAR resource loading)
            configManager.initialize();
            
            // 2. Initialize SQL queries and object repository
            sqlQueryManager.initialize();
            objectRepository.initialize();
            
            // 3. Initialize infrastructure
            initializeLogging();
            initializeSecretManager();
            
            // 4. Initialize core components
            Map<String, Object> config = new HashMap<>();
            config.put("configuration", configuration);
            
            dataSourceManager.initialize(config);
            driverManager.initialize(config);
            parallelEngine.initialize(config);
            sessionManager.initialize(config);
            
            // 5. Initialize reporting
            reportEngine.initialize(configuration);
            
            // 6. Initialize Azure DevOps if enabled
            if (adoIntegration != null) {
                adoIntegration.initialize(configuration);
            }
            
            // 7. Register shutdown hooks
            registerShutdownHooks();
            
            initialized.set(true);
            logger.info("CS Framework initialized successfully");
            
        } catch (Exception e) {
            logger.error("Failed to initialize CS Framework", e);
            initialized.set(false);
            throw new CSFrameworkException("Framework initialization failed", e);
        }
    }
}
```

### 4.2 CSContext (Thread-Safe Test Context)

```java
public class CSContext {
    private static final ThreadLocal<CSContext> threadLocalContext = new ThreadLocal<>();
    private static final AtomicLong contextIdGenerator = new AtomicLong(0);
    
    // Context Data
    private final long contextId;
    private final LocalDateTime createdAt;
    private final Map<String, Object> data = new ConcurrentHashMap<>();
    private final Map<String, Object> testData = new ConcurrentHashMap<>();
    private final Map<String, CSBasePage> pageObjects = new ConcurrentHashMap<>();
    private final Map<String, CSElement> elements = new ConcurrentHashMap<>();
    
    // Framework Components - No WebDriver exposure
    private CSConfiguration configuration;
    private CSDriver driver; // Framework wrapper, not WebDriver
    private CSBrowserManager browserManager;
    private CSSecretManager secretManager;
    
    // Test Execution State
    private String currentFeature;
    private String currentScenario;
    private String currentStep;
    private TestStatus testStatus = TestStatus.NOT_STARTED;
    private final List<Screenshot> screenshots = new CopyOnWriteArrayList<>();
    
    public CSContext() {
        this.contextId = contextIdGenerator.incrementAndGet();
        this.createdAt = LocalDateTime.now();
        this.configuration = CSConfiguration.getInstance();
        this.secretManager = new CSSecretManager();
        this.browserManager = new CSBrowserManager(this);
    }
    
    // Thread-safe context access
    public static CSContext getCurrentContext() {
        CSContext context = threadLocalContext.get();
        if (context == null) {
            context = new CSContext();
            threadLocalContext.set(context);
        }
        return context;
    }
    
    // Driver Management - Returns CSDriver, not WebDriver
    public CSDriver getDriver() {
        if (driver == null) {
            driver = CSDriverManager.getInstance().createDriver();
        }
        return driver;
    }
    
    // Navigation using CSDriver
    public void navigateTo(String url) {
        logger.info("Navigating to: {}", url);
        getDriver().get(url);
        waitForPageLoad();
    }
    
    private void waitForPageLoad() {
        getDriver().waitForPageLoad();
    }
}
```

### 4.3 SQL Query Manager

```java
public class CSSqlQueryManager {
    private static volatile CSSqlQueryManager instance;
    private final Map<String, String> queries = new ConcurrentHashMap<>();
    private final CSConfiguration configuration;
    private final CSLogger logger = CSLogger.getInstance();
    
    private CSSqlQueryManager() {
        this.configuration = CSConfiguration.getInstance();
    }
    
    public static CSSqlQueryManager getInstance() {
        if (instance == null) {
            synchronized (CSSqlQueryManager.class) {
                if (instance == null) {
                    instance = new CSSqlQueryManager();
                }
            }
        }
        return instance;
    }
    
    public void initialize() {
        String sqlQueriesFile = configuration.getString("cs.config.sql.queries", 
            "config/SqlQueries.properties");
        
        loadQueries(sqlQueriesFile);
    }
    
    private void loadQueries(String filePath) {
        try {
            Properties props = new Properties();
            
            // Try loading from file system first
            File file = new File(filePath);
            if (file.exists()) {
                try (InputStream input = new FileInputStream(file)) {
                    props.load(input);
                    logger.info("Loaded SQL queries from file: {}", filePath);
                }
            } else {
                // Try loading from classpath
                try (InputStream input = Thread.currentThread()
                        .getContextClassLoader()
                        .getResourceAsStream(filePath)) {
                    if (input != null) {
                        props.load(input);
                        logger.info("Loaded SQL queries from classpath: {}", filePath);
                    }
                }
            }
            
            // Store queries
            props.forEach((key, value) -> queries.put(key.toString(), value.toString()));
            
            logger.info("Loaded {} SQL queries", queries.size());
            
        } catch (IOException e) {
            logger.error("Failed to load SQL queries from: {}", filePath, e);
        }
    }
    
    public String getQuery(String queryKey) {
        String query = queries.get(queryKey);
        if (query == null) {
            throw new CSFrameworkException("SQL query not found for key: " + queryKey);
        }
        return query;
    }
    
    public boolean hasQuery(String queryKey) {
        return queries.containsKey(queryKey);
    }
}
```

### 4.4 Enhanced Object Repository

```java
public class CSObjectRepository {
    private static volatile CSObjectRepository instance;
    private final Map<String, String> locators = new ConcurrentHashMap<>();
    private final CSConfiguration configuration;
    private final CSLogger logger = CSLogger.getInstance();
    
    private CSObjectRepository() {
        this.configuration = CSConfiguration.getInstance();
    }
    
    public static CSObjectRepository getInstance() {
        if (instance == null) {
            synchronized (CSObjectRepository.class) {
                if (instance == null) {
                    instance = new CSObjectRepository();
                }
            }
        }
        return instance;
    }
    
    public void initialize() {
        String repositoryFile = configuration.getString("cs.config.object.repository", 
            "config/object-repository.properties");
        
        loadRepository(repositoryFile);
    }
    
    private void loadRepository(String filePath) {
        try {
            Properties props = new Properties();
            
            // Try loading from file system first
            File file = new File(filePath);
            if (file.exists()) {
                try (InputStream input = new FileInputStream(file)) {
                    props.load(input);
                    logger.info("Loaded object repository from file: {}", filePath);
                }
            } else {
                // Try loading from classpath
                try (InputStream input = Thread.currentThread()
                        .getContextClassLoader()
                        .getResourceAsStream(filePath)) {
                    if (input != null) {
                        props.load(input);
                        logger.info("Loaded object repository from classpath: {}", filePath);
                    }
                }
            }
            
            // Store locators
            props.forEach((key, value) -> locators.put(key.toString(), value.toString()));
            
            logger.info("Loaded {} locators", locators.size());
            
        } catch (IOException e) {
            logger.error("Failed to load object repository from: {}", filePath, e);
        }
    }
    
    public String getLocatorString(String key) {
        String locator = locators.get(key);
        if (locator == null) {
            throw new CSFrameworkException("Locator not found for key: " + key);
        }
        return locator;
    }
    
    public By getLocator(String key) {
        String locatorString = getLocatorString(key);
        return parseLocator(locatorString);
    }
    
    private By parseLocator(String locatorString) {
        if (locatorString.startsWith("id:")) {
            return By.id(locatorString.substring(3));
        } else if (locatorString.startsWith("name:")) {
            return By.name(locatorString.substring(5));
        } else if (locatorString.startsWith("css:")) {
            return By.cssSelector(locatorString.substring(4));
        } else if (locatorString.startsWith("xpath:")) {
            return By.xpath(locatorString.substring(6));
        } else if (locatorString.startsWith("class:")) {
            return By.className(locatorString.substring(6));
        } else if (locatorString.startsWith("tag:")) {
            return By.tagName(locatorString.substring(4));
        } else if (locatorString.startsWith("link:")) {
            return By.linkText(locatorString.substring(5));
        } else if (locatorString.startsWith("partial:")) {
            return By.partialLinkText(locatorString.substring(8));
        } else {
            // Default to CSS selector
            return By.cssSelector(locatorString);
        }
    }
    
    public boolean hasLocator(String key) {
        return locators.containsKey(key);
    }
}
```

---

## 5. Driver Management System

### 5.1 CSDriver - Framework WebDriver Wrapper

```java
/**
 * Framework wrapper for WebDriver - users never access WebDriver directly
 */
public interface CSDriver {
    void get(String url);
    String getCurrentUrl();
    String getTitle();
    String getPageSource();
    void close();
    void quit();
    CSWindow window();
    CSNavigation navigate();
    CSTargetLocator switchTo();
    Set<String> getWindowHandles();
    String getWindowHandle();
    CSElement findElement(By locator);
    List<CSElement> findElements(By locator);
    void waitForPageLoad();
    byte[] takeScreenshot();
    Object executeScript(String script, Object... args);
    Object executeAsyncScript(String script, Object... args);
}

/**
 * Implementation that wraps Selenium WebDriver
 */
public class CSDriverImpl implements CSDriver {
    private final WebDriver seleniumDriver;
    private final CSWaitHelper waitHelper;
    private final CSJavaScriptExecutor jsExecutor;
    private final CSConfiguration config;
    
    CSDriverImpl(WebDriver seleniumDriver) {
        this.seleniumDriver = seleniumDriver;
        this.waitHelper = new CSWaitHelper(seleniumDriver);
        this.jsExecutor = new CSJavaScriptExecutor(seleniumDriver);
        this.config = CSConfiguration.getInstance();
    }
    
    @Override
    public void get(String url) {
        logger.info("Navigating to URL: {}", url);
        seleniumDriver.get(url);
        waitForPageLoad();
    }
    
    @Override
    public CSElement findElement(By locator) {
        WebElement element = seleniumDriver.findElement(locator);
        return new CSElement(element, locator);
    }
    
    @Override
    public List<CSElement> findElements(By locator) {
        return seleniumDriver.findElements(locator).stream()
            .map(element -> new CSElement(element, locator))
            .collect(Collectors.toList());
    }
    
    @Override
    public void waitForPageLoad() {
        waitHelper.waitForPageLoad();
    }
    
    @Override
    public byte[] takeScreenshot() {
        return ((TakesScreenshot) seleniumDriver).getScreenshotAs(OutputType.BYTES);
    }
    
    @Override
    public Object executeScript(String script, Object... args) {
        return jsExecutor.executeScript(script, args);
    }
    
    // Other method implementations...
}
```

### 5.2 Enhanced CSDriverManager with Browser Capabilities

```java
public class CSDriverManager {
    private static volatile CSDriverManager instance;
    private static final ThreadLocal<CSDriver> threadLocalDriver = new ThreadLocal<>();
    
    private final CSDriverFactory driverFactory;
    private final CSConfiguration configuration;
    
    private CSDriverManager() {
        this.configuration = CSConfiguration.getInstance();
        this.driverFactory = new CSDriverFactory();
    }
    
    public CSDriver createDriver() {
        return createDriver(null);
    }
    
    public CSDriver createDriver(String browserType) {
        try {
            // Use configured browser if not specified
            if (browserType == null) {
                browserType = configuration.getString("cs.driver.browser", "chrome");
            }
            
            logger.info("Creating {} driver for thread: {}", 
                browserType, Thread.currentThread().getName());
            
            // Create Selenium WebDriver with capabilities
            WebDriver seleniumDriver = driverFactory.createSeleniumDriver(browserType);
            
            // Wrap in CSDriver
            CSDriver csDriver = new CSDriverImpl(seleniumDriver);
            
            // Store in thread-local
            threadLocalDriver.set(csDriver);
            
            // Configure driver
            configureDriver(csDriver);
            
            return csDriver;
            
        } catch (Exception e) {
            throw new CSDriverException("Failed to create driver: " + browserType, e);
        }
    }
    
    private void configureDriver(CSDriver driver) {
        // Set timeouts
        driver.manage().timeouts().implicitlyWait(
            Duration.ofSeconds(configuration.getImplicitWait()));
        driver.manage().timeouts().pageLoadTimeout(
            Duration.ofSeconds(configuration.getPageLoadTimeout()));
        
        // Window management
        boolean headless = configuration.getBoolean("cs.driver.headless", false);
        if (!headless && configuration.getBoolean("cs.driver.maximize", true)) {
            driver.window().maximize();
        }
        
        // Clean session
        if (configuration.getBoolean("cs.driver.clean.session", true)) {
            driver.manage().deleteAllCookies();
        }
    }
}

// Driver Factory with Additional Capabilities
public class CSDriverFactory {
    private final CSConfiguration configuration;
    
    public WebDriver createSeleniumDriver(String browserType) {
        switch (browserType.toLowerCase()) {
            case "chrome":
                return createChromeDriver();
            case "firefox":
                return createFirefoxDriver();
            case "edge":
                return createEdgeDriver();
            default:
                throw new CSDriverException("Unsupported browser: " + browserType);
        }
    }
    
    private WebDriver createChromeDriver() {
        ChromeOptions options = new ChromeOptions();
        
        // Default options
        boolean headless = configuration.getBoolean("cs.driver.headless", false);
        if (headless) {
            options.addArguments("--headless");
            options.addArguments("--window-size=1920,1080");
        }
        
        // Proxy configuration
        configureProxy(options);
        
        // Additional capabilities from properties
        Map<String, Object> additionalCaps = configuration.getSection("chrome.additional.capabilities");
        additionalCaps.forEach((key, value) -> {
            if (key.startsWith("args.")) {
                options.addArguments(value.toString());
            } else if (key.startsWith("prefs.")) {
                // Handle preferences
                options.setExperimentalOption(key.substring(6), value);
            } else {
                options.setCapability(key, value);
            }
        });
        
        WebDriverManager.chromedriver().setup();
        return new ChromeDriver(options);
    }
    
    private WebDriver createFirefoxDriver() {
        FirefoxOptions options = new FirefoxOptions();
        
        // Default options
        boolean headless = configuration.getBoolean("cs.driver.headless", false);
        if (headless) {
            options.addArguments("--headless");
            options.addArguments("--width=1920");
            options.addArguments("--height=1080");
        }
        
        // Proxy configuration
        configureProxy(options);
        
        // Additional capabilities from properties
        Map<String, Object> additionalCaps = configuration.getSection("firefox.additional.capabilities");
        additionalCaps.forEach((key, value) -> {
            if (key.startsWith("args.")) {
                options.addArguments(value.toString());
            } else if (key.startsWith("prefs.")) {
                options.addPreference(key.substring(6), value.toString());
            } else {
                options.setCapability(key, value);
            }
        });
        
        WebDriverManager.firefoxdriver().setup();
        return new FirefoxDriver(options);
    }
    
    private void configureProxy(MutableCapabilities capabilities) {
        if (configuration.getBoolean("cs.proxy.enabled", false)) {
            Proxy proxy = new Proxy();
            proxy.setProxyType(Proxy.ProxyType.MANUAL);
            
            String proxyHost = configuration.getString("cs.proxy.host");
            int proxyPort = configuration.getInt("cs.proxy.port", 8080);
            String proxyString = proxyHost + ":" + proxyPort;
            
            proxy.setHttpProxy(proxyString);
            proxy.setSslProxy(proxyString);
            
            // No proxy for
            String noProxy = configuration.getString("cs.proxy.no.proxy", "localhost,127.0.0.1");
            proxy.setNoProxy(noProxy);
            
            capabilities.setCapability(CapabilityType.PROXY, proxy);
        }
    }
}
```

---

## 6. Element Framework Design

### 6.1 Enhanced CSElement with Locator Key Support

```java
/**
 * Framework wrapper for WebElement with all Selenium capabilities plus enhancements
 * Users never interact with WebElement directly
 */
public class CSElement {
    private final WebElement seleniumElement;
    private final By locator;
    private final String locatorKey;
    private final String description;
    private final CSContext context;
    private final CSWaitStrategy waitStrategy;
    private final CSLogger logger;
    private final CSElementConfig config;
    
    // AI and Self-healing
    private final boolean aiEnabled;
    private final String descriptionText;
    private final List<By> alternativeLocators;
    private final CSElementHealer healer;
    
    public CSElement(By locator, String description) {
        this(null, locator, null, description, new CSElementConfig());
    }
    
    public CSElement(String locatorKey) {
        this(null, null, locatorKey, null, new CSElementConfig());
    }
    
    public CSElement(WebElement element, By locator) {
        this(element, locator, null, locator.toString(), new CSElementConfig());
    }
    
    private CSElement(WebElement element, By locator, String locatorKey, 
                     String description, CSElementConfig config) {
        // Validate mandatory fields
        if (locator == null && locatorKey == null) {
            throw new CSFrameworkException("Either locator or locatorKey must be provided");
        }
        
        this.seleniumElement = element;
        this.locator = locator != null ? locator : resolveLocatorFromKey(locatorKey);
        this.locatorKey = locatorKey;
        this.description = description != null ? description : 
            (locatorKey != null ? locatorKey : locator.toString());
        
        this.context = CSContext.getCurrentContext();
        this.waitStrategy = new CSWaitStrategy();
        this.logger = CSLogger.getInstance();
        this.config = config;
        
        // AI and self-healing setup
        this.aiEnabled = config.isAiEnabled();
        this.descriptionText = config.getDescriptionText();
        this.alternativeLocators = resolveAlternativeLocators(config.getAlternativeLocators());
        
        if (aiEnabled && descriptionText == null && 
            (alternativeLocators == null || alternativeLocators.isEmpty())) {
            throw new CSFrameworkException(
                "When AI is enabled, either descriptionText or alternativeLocators must be provided");
        }
        
        this.healer = aiEnabled ? new CSElementHealer(context.getDriver()) : null;
    }
    
    private List<By> resolveAlternativeLocators(List<String> alternativeLocatorStrings) {
        if (alternativeLocatorStrings == null || alternativeLocatorStrings.isEmpty()) {
            return new ArrayList<>();
        }
        
        List<By> resolvedLocators = new ArrayList<>();
        CSObjectRepository repository = CSObjectRepository.getInstance();
        
        for (String altLocator : alternativeLocatorStrings) {
            // Check if it's a repository key or direct locator
            if (repository.hasLocator(altLocator)) {
                // It's a repository key
                resolvedLocators.add(repository.getLocator(altLocator));
            } else if (altLocator.contains(":")) {
                // It's a direct locator (e.g., "css:.login-btn")
                resolvedLocators.add(parseDirectLocator(altLocator));
            } else {
                // Try to interpret as a repository key anyway
                logger.warn("Alternative locator '{}' not found in repository, skipping", altLocator);
            }
        }
        
        return resolvedLocators;
    }
    
    private By parseDirectLocator(String locatorString) {
        if (locatorString.startsWith("id:")) {
            return By.id(locatorString.substring(3));
        } else if (locatorString.startsWith("css:")) {
            return By.cssSelector(locatorString.substring(4));
        } else if (locatorString.startsWith("xpath:")) {
            return By.xpath(locatorString.substring(6));
        } else if (locatorString.startsWith("name:")) {
            return By.name(locatorString.substring(5));
        } else if (locatorString.startsWith("class:")) {
            return By.className(locatorString.substring(6));
        } else {
            return By.cssSelector(locatorString);
        }
    }
    
    // ==================== Core WebElement Methods ====================
    
    public void click() {
        performAction("click", () -> {
            WebElement element = getElement();
            
            // Scroll into view if needed
            if (config.isScrollIntoView()) {
                scrollIntoView();
            }
            
            // Highlight if enabled
            if (config.isHighlight()) {
                highlight();
            }
            
            // Wait for clickable
            if (config.isWaitForClickable()) {
                waitStrategy.waitForClickable(element, config.getTimeout());
            }
            
            try {
                element.click();
                logger.info("Clicked element: {}", description);
                reportAction("Click", description, "PASS");
            } catch (ElementClickInterceptedException e) {
                logger.warn("Click intercepted, trying JavaScript click");
                jsClick();
            }
        });
    }
    
    public void sendKeys(CharSequence... keys) {
        performAction("sendKeys", () -> {
            WebElement element = getElement();
            
            // Wait for visible
            if (config.isWaitForVisible()) {
                waitStrategy.waitForVisible(element, config.getTimeout());
            }
            
            // Clear if configured
            if (config.isClearBeforeType()) {
                element.clear();
            }
            
            // Decrypt if needed
            String text = String.join("", Arrays.stream(keys)
                .map(k -> CSSecretManager.decrypt(k.toString()))
                .toArray(String[]::new));
            
            element.sendKeys(text);
            logger.info("Typed text into element: {}", description);
            reportAction("SendKeys", description, "PASS");
            
            // Verify input if configured
            if (config.isVerifyInput()) {
                String actualValue = element.getAttribute("value");
                if (!actualValue.equals(text)) {
                    logger.warn("Input verification failed. Retrying with JS");
                    jsSetValue(text);
                }
            }
        });
    }
    
    public String getText() {
        return performAction("getText", () -> {
            WebElement element = getElement();
            String text = element.getText();
            
            // Try value attribute if text is empty
            if (text.isEmpty()) {
                text = element.getAttribute("value");
            }
            
            // Try textContent if still empty
            if (text.isEmpty()) {
                text = element.getAttribute("textContent");
            }
            
            logger.debug("Got text '{}' from element: {}", text, description);
            return text;
        });
    }
    
    public void clear() {
        performAction("clear", () -> {
            getElement().clear();
            logger.info("Cleared element: {}", description);
            reportAction("Clear", description, "PASS");
        });
    }
    
    public boolean isDisplayed() {
        try {
            return getElement().isDisplayed();
        } catch (NoSuchElementException e) {
            return false;
        }
    }
    
    public boolean isEnabled() {
        return getElement().isEnabled();
    }
    
    public boolean isSelected() {
        return getElement().isSelected();
    }
    
    public String getAttribute(String name) {
        return getElement().getAttribute(name);
    }
    
    public String getCssValue(String propertyName) {
        return getElement().getCssValue(propertyName);
    }
    
    public String getTagName() {
        return getElement().getTagName();
    }
    
    public Dimension getSize() {
        return getElement().getSize();
    }
    
    public Point getLocation() {
        return getElement().getLocation();
    }
    
    public Rectangle getRect() {
        return getElement().getRect();
    }
    
    // ==================== Actions Class Methods ====================
    
    public void doubleClick() {
        performAction("doubleClick", () -> {
            CSActions actions = new CSActions(context.getDriver());
            actions.doubleClick(this).perform();
            logger.info("Double clicked element: {}", description);
            reportAction("Double Click", description, "PASS");
        });
    }
    
    public void rightClick() {
        performAction("rightClick", () -> {
            CSActions actions = new CSActions(context.getDriver());
            actions.contextClick(this).perform();
            logger.info("Right clicked element: {}", description);
            reportAction("Right Click", description, "PASS");
        });
    }
    
    public void hover() {
        performAction("hover", () -> {
            CSActions actions = new CSActions(context.getDriver());
            actions.moveToElement(this).perform();
            logger.info("Hovered over element: {}", description);
            reportAction("Hover", description, "PASS");
        });
    }
    
    public void dragAndDropTo(CSElement target) {
        performAction("dragAndDrop", () -> {
            CSActions actions = new CSActions(context.getDriver());
            actions.dragAndDrop(this, target).perform();
            logger.info("Dragged {} to {}", description, target.description);
            reportAction("Drag and Drop", 
                String.format("%s to %s", description, target.description), "PASS");
        });
    }
    
    public void clickAndHold() {
        performAction("clickAndHold", () -> {
            CSActions actions = new CSActions(context.getDriver());
            actions.clickAndHold(this).perform();
            logger.info("Click and hold on element: {}", description);
            reportAction("Click and Hold", description, "PASS");
        });
    }
    
    public void release() {
        performAction("release", () -> {
            CSActions actions = new CSActions(context.getDriver());
            actions.release(this).perform();
            logger.info("Released element: {}", description);
            reportAction("Release", description, "PASS");
        });
    }
    
    // ==================== Select Class Methods ====================
    
    public void selectByText(String text) {
        performAction("selectByText", () -> {
            CSSelect select = new CSSelect(getElement());
            select.selectByVisibleText(text);
            logger.info("Selected '{}' from dropdown: {}", text, description);
            reportAction("Select by Text", 
                String.format("%s: %s", description, text), "PASS");
        });
    }
    
    public void selectByValue(String value) {
        performAction("selectByValue", () -> {
            CSSelect select = new CSSelect(getElement());
            select.selectByValue(value);
            logger.info("Selected value '{}' from dropdown: {}", value, description);
            reportAction("Select by Value", 
                String.format("%s: %s", description, value), "PASS");
        });
    }
    
    public void selectByIndex(int index) {
        performAction("selectByIndex", () -> {
            CSSelect select = new CSSelect(getElement());
            select.selectByIndex(index);
            logger.info("Selected index {} from dropdown: {}", index, description);
            reportAction("Select by Index", 
                String.format("%s: %d", description, index), "PASS");
        });
    }
    
    public List<String> getDropdownOptions() {
        return performAction("getDropdownOptions", () -> {
            CSSelect select = new CSSelect(getElement());
            return select.getOptions().stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
        });
    }
    
    public String getSelectedOption() {
        return performAction("getSelectedOption", () -> {
            CSSelect select = new CSSelect(getElement());
            return select.getFirstSelectedOption().getText();
        });
    }
    
    public List<String> getAllSelectedOptions() {
        return performAction("getAllSelectedOptions", () -> {
            CSSelect select = new CSSelect(getElement());
            return select.getAllSelectedOptions().stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
        });
    }
    
    public void deselectAll() {
        performAction("deselectAll", () -> {
            CSSelect select = new CSSelect(getElement());
            select.deselectAll();
            logger.info("Deselected all options in: {}", description);
            reportAction("Deselect All", description, "PASS");
        });
    }
    
    public void deselectByText(String text) {
        performAction("deselectByText", () -> {
            CSSelect select = new CSSelect(getElement());
            select.deselectByVisibleText(text);
            logger.info("Deselected '{}' from dropdown: {}", text, description);
            reportAction("Deselect by Text", 
                String.format("%s: %s", description, text), "PASS");
        });
    }
    
    // ==================== JavaScript Executor Methods ====================
    
    public void jsClick() {
        performAction("jsClick", () -> {
            executeScript("arguments[0].click();");
            logger.info("JavaScript clicked element: {}", description);
            reportAction("JS Click", description, "PASS");
        });
    }
    
    public void scrollIntoView() {
        performAction("scrollIntoView", () -> {
            executeScript(
                "arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});"
            );
            logger.debug("Scrolled element into view: {}", description);
        });
    }
    
    public void highlight() {
        performAction("highlight", () -> {
            String originalStyle = getAttribute("style");
            executeScript("arguments[0].style.border='3px solid red'");
            
            // Remove highlight after delay
            CompletableFuture.delayedExecutor(2, TimeUnit.SECONDS).execute(() -> {
                executeScript("arguments[0].style='" + originalStyle + "'");
            });
        });
    }
    
    public void jsSetValue(String value) {
        performAction("jsSetValue", () -> {
            executeScript("arguments[0].value = arguments[1];", value);
            logger.info("JavaScript set value in element: {}", description);
            reportAction("JS Set Value", description, "PASS");
        });
    }
    
    public void jsSetAttribute(String attribute, String value) {
        performAction("jsSetAttribute", () -> {
            executeScript(
                "arguments[0].setAttribute(arguments[1], arguments[2]);", 
                attribute, value
            );
            logger.info("Set attribute '{}' to '{}' on element: {}", 
                attribute, value, description);
        });
    }
    
    public void jsRemoveAttribute(String attribute) {
        performAction("jsRemoveAttribute", () -> {
            executeScript("arguments[0].removeAttribute(arguments[1]);", attribute);
            logger.info("Removed attribute '{}' from element: {}", attribute, description);
        });
    }
    
    public Object executeScript(String script, Object... args) {
        CSDriver driver = context.getDriver();
        Object[] fullArgs = new Object[args.length + 1];
        fullArgs[0] = getElement();
        System.arraycopy(args, 0, fullArgs, 1, args.length);
        return driver.executeScript(script, fullArgs);
    }
    
    // ==================== Enhanced Generic Methods ====================
    
    public void check() {
        performAction("check", () -> {
            if (!isSelected()) {
                click();
                logger.info("Checked checkbox: {}", description);
                reportAction("Check", description, "PASS");
            }
        });
    }
    
    public void uncheck() {
        performAction("uncheck", () -> {
            if (isSelected()) {
                click();
                logger.info("Unchecked checkbox: {}", description);
                reportAction("Uncheck", description, "PASS");
            }
        });
    }
    
    public void toggle() {
        performAction("toggle", () -> {
            click();
            logger.info("Toggled element: {}", description);
            reportAction("Toggle", description, "PASS");
        });
    }
    
    public void clearAndType(String text) {
        performAction("clearAndType", () -> {
            clear();
            sendKeys(text);
            logger.info("Cleared and typed in element: {}", description);
        });
    }
    
    public void typeSlowly(String text, int delayMs) {
        performAction("typeSlowly", () -> {
            for (char c : text.toCharArray()) {
                getElement().sendKeys(String.valueOf(c));
                try {
                    Thread.sleep(delayMs);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            logger.info("Typed slowly in element: {}", description);
        });
    }
    
    public void selectRadioButton() {
        performAction("selectRadioButton", () -> {
            if (!isSelected()) {
                click();
                logger.info("Selected radio button: {}", description);
                reportAction("Select Radio", description, "PASS");
            }
        });
    }
    
    public boolean hasClass(String className) {
        String classes = getAttribute("class");
        return classes != null && classes.contains(className);
    }
    
    public boolean hasAttribute(String attribute) {
        return getAttribute(attribute) != null;
    }
    
    public void waitAndClick() {
        waitForClickable();
        click();
    }
    
    public void clickIfPresent() {
        if (isPresent()) {
            click();
        }
    }
    
    public void clickWithRetry(int maxAttempts) {
        int attempts = 0;
        Exception lastException = null;
        
        while (attempts < maxAttempts) {
            try {
                click();
                return;
            } catch (Exception e) {
                lastException = e;
                attempts++;
                if (attempts < maxAttempts) {
                    logger.warn("Click failed, retrying... ({}/{})", attempts, maxAttempts);
                    waitFor(1);
                }
            }
        }
        
        throw new CSElementException("Failed to click after " + maxAttempts + " attempts", 
            lastException);
    }
    
    public String getInnerHTML() {
        return getAttribute("innerHTML");
    }
    
    public String getOuterHTML() {
        return getAttribute("outerHTML");
    }
    
    public void mouseOver() {
        hover();
    }
    
    public void focus() {
        performAction("focus", () -> {
            executeScript("arguments[0].focus();");
            logger.info("Focused on element: {}", description);
        });
    }
    
    public void blur() {
        performAction("blur", () -> {
            executeScript("arguments[0].blur();");
            logger.info("Blurred element: {}", description);
        });
    }
    
    public void pressEnter() {
        sendKeys(Keys.ENTER);
    }
    
    public void pressTab() {
        sendKeys(Keys.TAB);
    }
    
    public void pressEscape() {
        sendKeys(Keys.ESCAPE);
    }
    
    public void selectAll() {
        sendKeys(Keys.chord(Keys.CONTROL, "a"));
    }
    
    public void copy() {
        sendKeys(Keys.chord(Keys.CONTROL, "c"));
    }
    
    public void paste() {
        sendKeys(Keys.chord(Keys.CONTROL, "v"));
    }
    
    public void cut() {
        sendKeys(Keys.chord(Keys.CONTROL, "x"));
    }
    
    // ==================== Table Methods ====================
    
    public String getTableCellValue(int row, int column) {
        return performAction("getTableCellValue", () -> {
            String xpath = String.format(".//tr[%d]/td[%d]", row, column);
            WebElement cell = getElement().findElement(By.xpath(xpath));
            return cell.getText();
        });
    }
    
    public void clickTableCell(int row, int column) {
        performAction("clickTableCell", () -> {
            String xpath = String.format(".//tr[%d]/td[%d]", row, column);
            WebElement cell = getElement().findElement(By.xpath(xpath));
            cell.click();
            logger.info("Clicked table cell [{},{}] in: {}", row, column, description);
            reportAction("Click Table Cell", 
                String.format("%s[%d,%d]", description, row, column), "PASS");
        });
    }
    
    public int getTableRowCount() {
        return performAction("getTableRowCount", () -> {
            return getElement().findElements(By.tagName("tr")).size();
        });
    }
    
    public int getTableColumnCount() {
        return performAction("getTableColumnCount", () -> {
            List<WebElement> firstRow = getElement().findElements(By.xpath(".//tr[1]/td"));
            return firstRow.size();
        });
    }
    
    public List<String> getTableHeaders() {
        return performAction("getTableHeaders", () -> {
            return getElement().findElements(By.tagName("th")).stream()
                .map(WebElement::getText)
                .collect(Collectors.toList());
        });
    }
    
    public Map<String, String> getTableRowData(int row) {
        return performAction("getTableRowData", () -> {
            Map<String, String> rowData = new HashMap<>();
            List<WebElement> headers = getElement().findElements(By.tagName("th"));
            List<WebElement> cells = getElement()
                .findElements(By.xpath(String.format(".//tr[%d]/td", row)));
            
            for (int i = 0; i < headers.size() && i < cells.size(); i++) {
                rowData.put(headers.get(i).getText(), cells.get(i).getText());
            }
            
            return rowData;
        });
    }
    
    public List<Map<String, String>> getAllTableData() {
        return performAction("getAllTableData", () -> {
            List<Map<String, String>> allData = new ArrayList<>();
            int rowCount = getTableRowCount();
            
            for (int i = 2; i <= rowCount; i++) { // Start from 2 to skip header
                allData.add(getTableRowData(i));
            }
            
            return allData;
        });
    }
    
    // ==================== Wait Methods ====================
    
    public CSElement waitForVisible() {
        waitStrategy.waitForVisible(getElement(), config.getTimeout());
        return this;
    }
    
    public CSElement waitForClickable() {
        waitStrategy.waitForClickable(getElement(), config.getTimeout());
        return this;
    }
    
    public CSElement waitForText(String text) {
        waitStrategy.waitForText(getElement(), text, config.getTimeout());
        return this;
    }
    
    public CSElement waitForAttribute(String attribute, String value) {
        waitStrategy.waitForAttribute(getElement(), attribute, value, config.getTimeout());
        return this;
    }
    
    public CSElement waitUntilDisappears() {
        waitStrategy.waitForInvisible(locator, config.getTimeout());
        return this;
    }
    
    public CSElement waitFor(int seconds) {
        try {
            Thread.sleep(seconds * 1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return this;
    }
    
    // ==================== Validation Methods ====================
    
    public boolean isPresent() {
        try {
            getElement();
            return true;
        } catch (NoSuchElementException e) {
            return false;
        }
    }
    
    public void assertDisplayed() {
        if (!isDisplayed()) {
            throw new AssertionError("Element is not displayed: " + description);
        }
        reportAction("Assert Displayed", description, "PASS");
    }
    
    public void assertEnabled() {
        if (!isEnabled()) {
            throw new AssertionError("Element is not enabled: " + description);
        }
        reportAction("Assert Enabled", description, "PASS");
    }
    
    public void assertText(String expected) {
        String actual = getText();
        if (!actual.equals(expected)) {
            reportAction("Assert Text", 
                String.format("%s - Expected: %s, Actual: %s", description, expected, actual), 
                "FAIL");
            throw new AssertionError(
                String.format("Text mismatch for %s. Expected: %s, Actual: %s", 
                    description, expected, actual));
        }
        reportAction("Assert Text", 
            String.format("%s: %s", description, expected), "PASS");
    }
    
    public void assertContainsText(String expected) {
        String actual = getText();
        if (!actual.contains(expected)) {
            reportAction("Assert Contains Text", 
                String.format("%s - Expected to contain: %s, Actual: %s", 
                    description, expected, actual), "FAIL");
            throw new AssertionError(
                String.format("Element %s does not contain text: %s", description, expected));
        }
        reportAction("Assert Contains Text", 
            String.format("%s contains: %s", description, expected), "PASS");
    }
    
    // ==================== Screenshot Methods ====================
    
    public byte[] takeScreenshot() {
        return getElement().getScreenshotAs(OutputType.BYTES);
    }
    
    public void takeScreenshot(String name) {
        byte[] screenshot = takeScreenshot();
        context.saveScreenshot(name, screenshot);
    }
    
    // ==================== Configuration Methods ====================
    
    public CSElement withTimeout(int seconds) {
        config.setTimeout(seconds);
        return this;
    }
    
    public CSElement withDescription(String description) {
        this.description = description;
        return this;
    }
    
    public CSElement withoutScroll() {
        config.setScrollIntoView(false);
        return this;
    }
    
    public CSElement withHighlight() {
        config.setHighlight(true);
        return this;
    }
    
    public CSElement withoutWait() {
        config.setWaitForVisible(false);
        config.setWaitForClickable(false);
        return this;
    }
    
    // ==================== Helper Methods ====================
    
    private WebElement getElement() {
        try {
            if (seleniumElement != null) {
                return seleniumElement;
            }
            
            // Get fresh element using framework driver
            CSDriver driver = context.getDriver();
            return driver.findElement(locator).getSeleniumElement();
            
        } catch (NoSuchElementException e) {
            if (aiEnabled && healer != null) {
                logger.info("Element not found, attempting self-healing");
                return attemptSelfHealing();
            }
            
            logger.error("Element not found: {}", description);
            throw new CSElementException("Element not found: " + description, e);
        }
    }
    
    private WebElement attemptSelfHealing() {
        try {
            // Try alternative locators first
            if (alternativeLocators != null && !alternativeLocators.isEmpty()) {
                for (By altLocator : alternativeLocators) {
                    try {
                        WebElement element = context.getDriver()
                            .findElement(altLocator).getSeleniumElement();
                        if (element.isDisplayed()) {
                            logger.info("Self-healing succeeded with alternative locator: {}", 
                                altLocator);
                            reportAction("Self-Healing", 
                                String.format("Found %s using: %s", description, altLocator), 
                                "PASS");
                            return element;
                        }
                    } catch (Exception ignored) {
                        // Try next alternative
                    }
                }
            }
            
            // Try AI-based healing if description text is provided
            if (descriptionText != null) {
                WebElement healed = healer.healElement(locator, descriptionText);
                if (healed != null) {
                    logger.info("Self-healing succeeded using AI for: {}", description);
                    reportAction("AI Self-Healing", description, "PASS");
                    return healed;
                }
            }
            
            throw new CSElementException("Self-healing failed for: " + description);
            
        } catch (Exception e) {
            logger.error("Self-healing failed for element: {}", description, e);
            throw new CSElementException("Self-healing failed: " + description, e);
        }
    }
    
    private <T> T performAction(String actionName, Supplier<T> action) {
        logger.debug("Performing {} on element: {}", actionName, description);
        
        try {
            return action.get();
        } catch (StaleElementReferenceException e) {
            logger.warn("Stale element detected. Retrying {}", actionName);
            return action.get(); // Retry once
        } catch (Exception e) {
            logger.error("Failed to perform {} on element: {}", actionName, description, e);
            reportAction(actionName, description, "FAIL");
            throw new CSElementException(
                String.format("Failed to perform %s on element: %s", actionName, description), e);
        }
    }
    
    private void reportAction(String action, String details, String status) {
        CSReportEngine.getInstance().logCustomStep(action, details, status);
    }
    
    private By resolveLocatorFromKey(String key) {
        return CSObjectRepository.getInstance().getLocator(key);
    }
    
    // Package-private method to get selenium element for framework internal use
    WebElement getSeleniumElement() {
        return getElement();
    }
}

// Enhanced Element Configuration
public class CSElementConfig {
    private int timeout = 30;
    private boolean waitForVisible = true;
    private boolean waitForClickable = true;
    private boolean scrollIntoView = true;
    private boolean highlight = false;
    private boolean clearBeforeType = true;
    private boolean verifyInput = false;
    private boolean aiEnabled = false;
    private String descriptionText;
    private List<String> alternativeLocators = new ArrayList<>();
    
    // Builder pattern methods
    public CSElementConfig withTimeout(int timeout) {
        this.timeout = timeout;
        return this;
    }
    
    public CSElementConfig withAI(String descriptionText) {
        this.aiEnabled = true;
        this.descriptionText = descriptionText;
        return this;
    }
    
    public CSElementConfig withAlternatives(String... locators) {
        this.aiEnabled = true;
        this.alternativeLocators = Arrays.asList(locators);
        return this;
    }
    
    // Getters and setters...
}
```

### 6.2 Smart Wait Strategy

```java
public class CSWaitStrategy {
    private final CSConfiguration config;
    private final int defaultTimeout;
    private final int pollingInterval;
    
    public CSWaitStrategy() {
        this.config = CSConfiguration.getInstance();
        this.defaultTimeout = config.getInt("cs.wait.timeout", 30);
        this.pollingInterval = config.getInt("cs.wait.polling", 500);
    }
    
    public WebElement waitForVisible(WebElement element, int timeout) {
        CSDriverWait wait = createWait(timeout);
        return wait.until(CSExpectedConditions.visibilityOf(element));
    }
    
    public WebElement waitForClickable(WebElement element, int timeout) {
        CSDriverWait wait = createWait(timeout);
        return wait.until(CSExpectedConditions.elementToBeClickable(element));
    }
    
    public boolean waitForText(WebElement element, String text, int timeout) {
        CSDriverWait wait = createWait(timeout);
        return wait.until(CSExpectedConditions.textToBePresentInElement(element, text));
    }
    
    public boolean waitForAttribute(WebElement element, String attribute, String value, int timeout) {
        CSDriverWait wait = createWait(timeout);
        return wait.until(driver -> {
            String actualValue = element.getAttribute(attribute);
            return actualValue != null && actualValue.equals(value);
        });
    }
    
    public boolean waitForInvisible(By locator, int timeout) {
        CSDriverWait wait = createWait(timeout);
        return wait.until(CSExpectedConditions.invisibilityOfElementLocated(locator));
    }
    
    private CSDriverWait createWait(int timeout) {
        CSDriver driver = CSContext.getCurrentContext().getDriver();
        CSDriverWait wait = new CSDriverWait(driver, Duration.ofSeconds(timeout));
        wait.pollingEvery(Duration.ofMillis(pollingInterval));
        return wait;
    }
}
```

---

## 7. Page Object Model Implementation

### 7.1 Enhanced Page Object Base with Locator Key Support

```java
// Enhanced CSLocator annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CSLocator {
    String locatorKey() default "";
    String id() default "";
    String name() default "";
    String css() default "";
    String xpath() default "";
    String className() default "";
    String tagName() default "";
    String linkText() default "";
    ```java
    String partialLinkText() default "";
    
    String description() default "";
    boolean aiEnabled() default false;
    String aiDescription() default "";
    String[] alternativeLocators() default {};
    
    int timeoutInSeconds() default 30;
    boolean waitForVisible() default true;
    boolean waitForClickable() default true;
}

// Updated CSBasePage
public abstract class CSBasePage {
    protected final CSContext context;
    protected final CSDriver driver;
    protected final CSElementFactory elementFactory;
    protected final CSWaitHelper waitHelper;
    protected final CSLogger logger;
    
    public CSBasePage() {
        this.context = CSContext.getCurrentContext();
        this.driver = context.getDriver();
        this.elementFactory = new CSElementFactory();
        this.waitHelper = new CSWaitHelper(driver);
        this.logger = CSLogger.getInstance();
        
        // Initialize page elements
        initializeElements();
        
        // Wait for page load
        waitForPageLoad();
        
        logger.debug("Initialized page: {}", this.getClass().getSimpleName());
    }
    
    /**
     * Initialize page elements using reflection and annotations
     */
    private void initializeElements() {
        Field[] fields = this.getClass().getDeclaredFields();
        
        for (Field field : fields) {
            if (field.isAnnotationPresent(CSLocator.class)) {
                CSLocator locator = field.getAnnotation(CSLocator.class);
                
                try {
                    field.setAccessible(true);
                    
                    if (CSElement.class.isAssignableFrom(field.getType())) {
                        // Create single element
                        CSElement element = createElementFromAnnotation(locator);
                        field.set(this, element);
                    } else if (List.class.isAssignableFrom(field.getType())) {
                        // Create element list
                        List<CSElement> elements = createElementsFromAnnotation(locator);
                        field.set(this, elements);
                    }
                } catch (Exception e) {
                    throw new CSFrameworkException("Failed to initialize field: " + field.getName(), e);
                }
            }
        }
    }
    
    private CSElement createElementFromAnnotation(CSLocator locator) {
        CSElementConfig config = new CSElementConfig()
            .withTimeout(locator.timeoutInSeconds())
            .withAI(locator.aiDescription())
            .withAlternatives(locator.alternativeLocators());
        
        if (!locator.locatorKey().isEmpty()) {
            return new CSElement(locator.locatorKey());
        } else {
            By by = createByFromAnnotation(locator);
            return new CSElement(by, locator.description());
        }
    }
    
    private List<CSElement> createElementsFromAnnotation(CSLocator locator) {
        By by = createByFromAnnotation(locator);
        return driver.findElements(by);
    }
    
    private By createByFromAnnotation(CSLocator locator) {
        if (!locator.id().isEmpty()) {
            return By.id(locator.id());
        } else if (!locator.name().isEmpty()) {
            return By.name(locator.name());
        } else if (!locator.css().isEmpty()) {
            return By.cssSelector(locator.css());
        } else if (!locator.xpath().isEmpty()) {
            return By.xpath(locator.xpath());
        } else if (!locator.className().isEmpty()) {
            return By.className(locator.className());
        } else if (!locator.tagName().isEmpty()) {
            return By.tagName(locator.tagName());
        } else if (!locator.linkText().isEmpty()) {
            return By.linkText(locator.linkText());
        } else if (!locator.partialLinkText().isEmpty()) {
            return By.partialLinkText(locator.partialLinkText());
        } else {
            throw new CSFrameworkException("No valid locator specified in @CSLocator annotation");
        }
    }
    
    /**
     * Wait for page to load completely
     */
    protected void waitForPageLoad() {
        waitHelper.waitForPageLoad();
        
        // Additional page-specific wait
        if (this instanceof PageLoadWait) {
            ((PageLoadWait) this).waitForPageReady();
        }
    }
    
    /**
     * Navigate to page URL
     */
    public void navigateTo(String url) {
        logger.info("Navigating to: {}", url);
        driver.get(url);
        waitForPageLoad();
    }
    
    /**
     * Get page title
     */
    public String getTitle() {
        return driver.getTitle();
    }
    
    /**
     * Get current URL
     */
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Check if page is displayed
     */
    public abstract boolean isDisplayed();
    
    /**
     * Take screenshot of page
     */
    public void takeScreenshot(String name) {
        byte[] screenshot = driver.takeScreenshot();
        context.saveScreenshot(name, screenshot);
    }
    
    /**
     * Execute JavaScript on page
     */
    protected Object executeScript(String script, Object... args) {
        return driver.executeScript(script, args);
    }
    
    /**
     * Find element dynamically (always fresh)
     */
    protected CSElement findElement(By locator) {
        return driver.findElement(locator);
    }
    
    /**
     * Find multiple elements dynamically
     */
    protected List<CSElement> findElements(By locator) {
        return driver.findElements(locator);
    }
}
```

---

## 8. BDD Integration & Enhanced Features

### 8.1 Unified BDD Step Definition

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CSBDDStep {
    /**
     * Step pattern that matches all Gherkin keywords
     */
    String description();
    
    /**
     * Priority for step matching (higher = preferred)
     */
    int priority() default 0;
    
    /**
     * Take screenshot after step execution
     */
    boolean screenshot() default false;
    
    /**
     * Log level for this step
     */
    LogLevel logLevel() default LogLevel.INFO;
    
    /**
     * Retry count on failure
     */
    int retry() default 0;
    
    /**
     * Custom timeout for this step
     */
    int timeout() default -1;
}
```

### 8.2 Enhanced Step Definition Implementation

```java
public class CSStepDefinitions {
    protected final CSContext context;
    protected final CSLogger logger;
    protected final CSReportEngine reporter;
    
    public CSStepDefinitions() {
        this.context = CSContext.getCurrentContext();
        this.logger = CSLogger.getInstance();
        this.reporter = CSReportEngine.getInstance();
    }
    
    @CSBDDStep(description = "I am on the {string} page")
    public void navigateToPage(String pageName) {
        logger.info("Navigating to {} page", pageName);
        reporter.logStep("Navigate to " + pageName + " page");
        
        String url = getPageUrl(pageName);
        context.navigateTo(url);
        
        // Verify navigation
        verifyPageLoaded(pageName);
    }
    
    @CSBDDStep(description = "I enter {string} in the {string} field")
    public void enterTextInField(String text, String fieldName) {
        // Auto-decrypt if encrypted
        String actualText = CSSecretManager.decrypt(text);
        
        CSElement field = findFieldByName(fieldName);
        field.sendKeys(actualText);
        
        logger.info("Entered text in {} field", fieldName);
        reporter.logStep("Enter text in " + fieldName + " field");
    }
    
    @CSBDDStep(description = "I click the {string} button", screenshot = true)
    public void clickButton(String buttonName) {
        CSElement button = findButtonByName(buttonName);
        button.click();
        
        logger.info("Clicked {} button", buttonName);
        reporter.logStep("Click " + buttonName + " button");
    }
    
    @CSBDDStep(description = "I should see {string}")
    public void verifySee(String expectedText) {
        CSBasePage currentPage = context.getCurrentPage();
        boolean found = currentPage.getPageSource().contains(expectedText);
        
        if (!found) {
            reporter.logStep("Verify text visible: " + expectedText, "FAIL");
            throw new AssertionError("Expected text not found: " + expectedText);
        }
        
        logger.info("Verified text is visible: {}", expectedText);
        reporter.logStep("Verify text visible: " + expectedText, "PASS");
    }
}
```

---

## 9. Configuration Management System

### 9.1 Enhanced JAR-Aware Configuration Management

```java
public class CSConfiguration {
    private static volatile CSConfiguration instance;
    
    // Configuration sources in priority order
    private final List<ConfigurationSource> configSources = new ArrayList<>();
    private final Map<String, String> resolvedConfig = new ConcurrentHashMap<>();
    private final Map<String, String> cache = new ConcurrentHashMap<>();
    
    private CSConfiguration() {
        initializeConfigurationSources();
        loadConfigurations();
    }
    
    private void initializeConfigurationSources() {
        // Add sources in priority order (highest to lowest)
        configSources.add(new SystemPropertySource());      // System properties
        configSources.add(new EnvironmentVariableSource()); // Environment variables
        configSources.add(new TestConfigurationSource());   // Test-level config
        configSources.add(new UserPropertyFileSource());    // User's application.properties
        configSources.add(new JarPropertyFileSource());     // Framework defaults in JAR
    }
    
    private void loadConfigurations() {
        // Load from each source in reverse order (defaults first)
        List<ConfigurationSource> reversedSources = new ArrayList<>(configSources);
        Collections.reverse(reversedSources);
        
        for (ConfigurationSource source : reversedSources) {
            try {
                Map<String, String> config = source.load();
                resolvedConfig.putAll(config);
                logger.debug("Loaded {} properties from {}", 
                    config.size(), source.getName());
            } catch (Exception e) {
                logger.warn("Failed to load configuration from {}: {}", 
                    source.getName(), e.getMessage());
            }
        }
        
        // Decrypt encrypted values
        decryptValues();
        
        // Resolve placeholders
        resolvePlaceholders();
    }
    
    // Get configuration section for additional capabilities
    public Map<String, Object> getSection(String prefix) {
        Map<String, Object> section = new HashMap<>();
        
        resolvedConfig.forEach((key, value) -> {
            if (key.startsWith(prefix + ".")) {
                String subKey = key.substring(prefix.length() + 1);
                section.put(subKey, value);
            }
        });
        
        return section;
    }
    
    public static CSConfiguration getInstance() {
        if (instance == null) {
            synchronized (CSConfiguration.class) {
                if (instance == null) {
                    instance = new CSConfiguration();
                }
            }
        }
        return instance;
    }
    
    public String getString(String key) {
        return getString(key, null);
    }
    
    public String getString(String key, String defaultValue) {
        String value = resolvedConfig.get(key);
        return value != null ? value : defaultValue;
    }
    
    public int getInt(String key, int defaultValue) {
        String value = getString(key);
        return value != null ? Integer.parseInt(value) : defaultValue;
    }
    
    public boolean getBoolean(String key, boolean defaultValue) {
        String value = getString(key);
        return value != null ? Boolean.parseBoolean(value) : defaultValue;
    }
    
    public Set<String> getAllKeys() {
        return new HashSet<>(resolvedConfig.keySet());
    }
    
    public boolean hasKey(String key) {
        return resolvedConfig.containsKey(key);
    }
}

// JAR-aware property file source
public class JarPropertyFileSource implements ConfigurationSource {
    @Override
    public Map<String, String> load() {
        Properties props = new Properties();
        
        // Load from JAR resources
        try (InputStream input = CSConfiguration.class
                .getResourceAsStream("/cs-framework-defaults.properties")) {
            if (input != null) {
                props.load(input);
                logger.info("Loaded framework defaults from JAR");
            }
        } catch (IOException e) {
            logger.debug("Could not load JAR defaults: {}", e.getMessage());
        }
        
        Map<String, String> config = new HashMap<>();
        props.forEach((key, value) -> config.put(key.toString(), value.toString()));
        
        return config;
    }
    
    @Override
    public String getName() {
        return "JAR Defaults";
    }
}

// User property file source
public class UserPropertyFileSource implements ConfigurationSource {
    @Override
    public Map<String, String> load() {
        Properties props = new Properties();
        
        // Try multiple locations for application.properties
        String[] locations = {
            "application.properties",
            "src/test/resources/application.properties",
            "config/application.properties"
        };
        
        for (String location : locations) {
            // Try file system first
            File file = new File(location);
            if (file.exists()) {
                try (InputStream input = new FileInputStream(file)) {
                    props.load(input);
                    logger.info("Loaded user properties from: {}", location);
                    break;
                } catch (IOException e) {
                    logger.debug("Failed to load from file: {}", location);
                }
            }
            
            // Try classpath
            try (InputStream input = Thread.currentThread()
                    .getContextClassLoader()
                    .getResourceAsStream(location)) {
                if (input != null) {
                    props.load(input);
                    logger.info("Loaded user properties from classpath: {}", location);
                    break;
                }
            } catch (IOException e) {
                logger.debug("Failed to load from classpath: {}", location);
            }
        }
        
        Map<String, String> config = new HashMap<>();
        props.forEach((key, value) -> config.put(key.toString(), value.toString()));
        
        return config;
    }
    
    @Override
    public String getName() {
        return "User Properties";
    }
}
```

---

## 10. Secret Management & Encryption

### 10.1 Simple Secret Manager

```java
public class CSSecretManager {
    private static final String ENC_PREFIX = "ENC(";
    private static final String ENC_SUFFIX = ")";
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int KEY_SIZE = 256;
    private static final int IV_SIZE = 12;
    private static final int TAG_SIZE = 128;
    
    private static SecretKey masterKey;
    private static final CSLogger logger = CSLogger.getInstance();
    
    static {
        initializeMasterKey();
    }
    
    private static void initializeMasterKey() {
        // Try to get master key from environment
        String encodedKey = System.getenv("CS_MASTER_KEY");
        
        if (encodedKey != null) {
            try {
                byte[] decodedKey = Base64.getDecoder().decode(encodedKey);
                masterKey = new SecretKeySpec(decodedKey, "AES");
                logger.info("Master key loaded from environment");
            } catch (Exception e) {
                logger.error("Failed to load master key from environment", e);
            }
        }
        
        // Generate default key if not provided (development only)
        if (masterKey == null) {
            logger.warn("No master key found. Generating default key (NOT FOR PRODUCTION)");
            masterKey = generateDefaultKey();
        }
    }
    
    /**
     * Decrypt value if encrypted, otherwise return as-is
     */
    public static String decrypt(String value) {
        if (value == null || !isEncrypted(value)) {
            return value;
        }
        
        try {
            String encrypted = value.substring(4, value.length() - 1);
            byte[] combined = Base64.getDecoder().decode(encrypted);
            
            // Extract IV and encrypted data
            byte[] iv = Arrays.copyOfRange(combined, 0, IV_SIZE);
            byte[] cipherText = Arrays.copyOfRange(combined, IV_SIZE, combined.length);
            
            // Decrypt
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec spec = new GCMParameterSpec(TAG_SIZE, iv);
            cipher.init(Cipher.DECRYPT_MODE, masterKey, spec);
            
            byte[] plainText = cipher.doFinal(cipherText);
            return new String(plainText, StandardCharsets.UTF_8);
            
        } catch (Exception e) {
            logger.error("Decryption failed for value", e);
            throw new CSFrameworkException("Decryption failed", e);
        }
    }
    
    /**
     * Encrypt a plain text value
     */
    public static String encrypt(String plainText) {
        if (plainText == null || plainText.isEmpty()) {
            return plainText;
        }
        
        try {
            // Generate random IV
            byte[] iv = new byte[IV_SIZE];
            SecureRandom random = new SecureRandom();
            random.nextBytes(iv);
            
            // Encrypt
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec spec = new GCMParameterSpec(TAG_SIZE, iv);
            cipher.init(Cipher.ENCRYPT_MODE, masterKey, spec);
            
            byte[] cipherText = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
            
            // Combine IV and cipher text
            byte[] combined = new byte[iv.length + cipherText.length];
            System.arraycopy(iv, 0, combined, 0, iv.length);
            System.arraycopy(cipherText, 0, combined, iv.length, cipherText.length);
            
            // Return formatted encrypted value
            return ENC_PREFIX + Base64.getEncoder().encodeToString(combined) + ENC_SUFFIX;
            
        } catch (Exception e) {
            logger.error("Encryption failed", e);
            throw new CSFrameworkException("Encryption failed", e);
        }
    }
    
    /**
     * Check if value is encrypted
     */
    public static boolean isEncrypted(String value) {
        return value != null && 
               value.startsWith(ENC_PREFIX) && 
               value.endsWith(ENC_SUFFIX) &&
               value.length() > 5;
    }
    
    /**
     * Generate default key for development
     */
    private static SecretKey generateDefaultKey() {
        try {
            KeyGenerator keyGen = KeyGenerator.getInstance("AES");
            keyGen.init(KEY_SIZE);
            return keyGen.generateKey();
        } catch (Exception e) {
            throw new CSFrameworkException("Failed to generate default key", e);
        }
    }
}
```

---

## 11. Data Management Layer

### 11.1 Enhanced Data Source Manager with SQL Query Key Support

```java
public class CSDataSourceManager {
    private static volatile CSDataSourceManager instance;
    private final Map<String, DataReader> readers = new ConcurrentHashMap<>();
    private final CSLogger logger = CSLogger.getInstance();
    
    private CSDataSourceManager() {
        registerDefaultReaders();
    }
    
    private void registerDefaultReaders() {
        readers.put("excel", new ExcelDataReader());
        readers.put("csv", new CSVDataReader());
        readers.put("json", new JSONDataReader());
        readers.put("xml", new XMLDataReader());
        readers.put("database", new DatabaseDataReader());
        readers.put("api", new APIDataReader());
    }
    
    public static CSDataSourceManager getInstance() {
        if (instance == null) {
            synchronized (CSDataSourceManager.class) {
                if (instance == null) {
                    instance = new CSDataSourceManager();
                }
            }
        }
        return instance;
    }
    
    public Object[][] getData(String dataSource) {
        DataSourceConfig config = parseDataSource(dataSource);
        DataReader reader = getReader(config.getType());
        
        // Load raw data
        List<Map<String, String>> rawData = reader.read(config);
        
        // Apply filters
        if (config.hasFilter()) {
            rawData = applyFilters(rawData, config.getFilter());
        }
        
        // Decrypt sensitive data
        rawData = decryptData(rawData);
        
        // Transform to Object[][]
        return transformData(rawData);
    }
    
    private List<Map<String, String>> decryptData(List<Map<String, String>> data) {
        return data.stream()
            .map(row -> {
                Map<String, String> decryptedRow = new HashMap<>();
                row.forEach((key, value) -> {
                    decryptedRow.put(key, CSSecretManager.decrypt(value));
                });
                return decryptedRow;
            })
            .collect(Collectors.toList());
    }
    
    private DataReader getReader(String type) {
        DataReader reader = readers.get(type.toLowerCase());
        if (reader == null) {
            throw new CSDataException("Unsupported data source type: " + type);
        }
        return reader;
    }
    
    private DataSourceConfig parseDataSource(String dataSource) {
        DataSourceConfig config = new DataSourceConfig();
        
        // Parse key-value pairs
        String[] parts = dataSource.split(",");
        for (String part : parts) {
            String[] kv = part.trim().split("=", 2);
            if (kv.length == 2) {
                String key = kv[0].trim();
                String value = kv[1].trim();
                
                switch (key) {
                    case "type":
                        config.setType(value);
                        break;
                    case "location":
                    case "source":
                        config.setLocation(value);
                        break;
                    case "sheet":
                        config.setSheet(value);
                        break;
                    case "key":
                        config.setKeyField(value);
                        break;
                    case "filter":
                        config.setFilter(value);
                        break;
                    case "name":
                        config.setDatabaseName(value);
                        break;
                    case "query":
                        config.setQuery(value);
                        break;
                    case "queryKey":
                        // Resolve query from SQL query manager
                        String query = CSSqlQueryManager.getInstance().getQuery(value);
                        config.setQuery(query);
                        break;
                }
            }
        }
        
        return config;
    }
}

// Enhanced Database Data Reader
public class DatabaseDataReader implements DataReader {
    private final CSLogger logger = CSLogger.getInstance();
    
    @Override
    public List<Map<String, String>> read(DataSourceConfig config) {
        String dbName = config.getDatabaseName();
        String query = config.getQuery();
        
        if (dbName == null || query == null) {
            throw new CSDataException("Database name and query are required for database data source");
        }
        
        logger.info("Reading data from database '{}' with query", dbName);
        
        CSDatabase database = CSDatabaseManager.getInstance().getDatabase(dbName);
        List<Map<String, Object>> results = database.query(query);
        
        // Convert to Map<String, String>
        return results.stream()
            .map(row -> {
                Map<String, String> stringRow = new HashMap<>();
                row.forEach((key, value) -> {
                    stringRow.put(key, value != null ? value.toString() : "");
                });
                return stringRow;
            })
            .collect(Collectors.toList());
    }
}

// Enhanced Excel Data Reader with Key Field Support
public class ExcelDataReader implements DataReader {
    private final CSLogger logger = CSLogger.getInstance();
    
    @Override
    public List<Map<String, String>> read(DataSourceConfig config) {
        String location = config.getLocation();
        String sheet = config.getSheet();
        String keyField = config.getKeyField();
        String filter = config.getFilter();
        
        logger.info("Reading Excel data from: {} (sheet: {}, key: {}, filter: {})", 
            location, sheet, keyField, filter);
        
        return CSExcelUtils.readExcel(location, sheet, keyField, filter);
    }
}

// Enhanced CSV Data Reader with Key Field Support
public class CSVDataReader implements DataReader {
    private final CSLogger logger = CSLogger.getInstance();
    
    @Override
    public List<Map<String, String>> read(DataSourceConfig config) {
        String location = config.getLocation();
        String keyField = config.getKeyField();
        String filter = config.getFilter();
        
        logger.info("Reading CSV data from: {} (key: {}, filter: {})", 
            location, keyField, filter);
        
        return CSCsvUtils.readCsv(location, keyField, filter);
    }
}

// Data Source Configuration
public class DataSourceConfig {
    private String type;
    private String location;
    private String sheet;
    private String keyField;
    private String filter;
    private String databaseName;
    private String query;
    
    // Getters and setters...
}
```

---

## 12. Reporting System

### 12.1 Enhanced Report Engine with Custom Logging

```java
public class CSReportEngine {
    private static volatile CSReportEngine instance;
    
    // Report components
    private final ExtentReports extentReports;
    private final Map<String, ExtentTest> testMap = new ConcurrentHashMap<>();
    private final List<ReportListener> listeners = new CopyOnWriteArrayList<>();
    
    // Report data
    private final TestExecutionSummary summary;
    private final List<TestResult> testResults = new CopyOnWriteArrayList<>();
    private final Map<String, List<TestStep>> testSteps = new ConcurrentHashMap<>();
    
    // Configuration
    private String reportDir;
    private boolean captureScreenshots;
    private CSAzureDevOpsIntegration adoIntegration;
    
    private CSReportEngine() {
        this.extentReports = new ExtentReports();
        this.summary = new TestExecutionSummary();
        initialize();
    }
    
    public static CSReportEngine getInstance() {
        if (instance == null) {
            synchronized (CSReportEngine.class) {
                if (instance == null) {
                    instance = new CSReportEngine();
                }
            }
        }
        return instance;
    }
    
    public void logStep(String description) {
        logStep(description, Status.INFO);
    }
    
    public void logStep(String description, Status status) {
        ExtentTest test = getCurrentTest();
        if (test != null) {
            test.log(status, description);
        }
        
        // Track step
        String testName = getCurrentTestName();
        testSteps.computeIfAbsent(testName, k -> new ArrayList<>())
            .add(new TestStep(description, status));
    }
    
    /**
     * Custom reporting method for user actions
     * @param action The action performed
     * @param details Action details
     * @param status PASS, FAIL, WARN, INFO
     */
    public void logCustomStep(String action, String details, String status) {
        Status extentStatus = mapStatus(status);
        String message = String.format("[%s] %s", action, details);
        
        ExtentTest test = getCurrentTest();
        if (test != null) {
            test.log(extentStatus, message);
            
            // Capture screenshot for failures
            if ("FAIL".equalsIgnoreCase(status) && captureScreenshots) {
                captureAndAttachScreenshot(test, action);
            }
        }
        
        // Log to console
        logger.info("{}: {} - {}", action, details, status);
        
        // Update ADO if enabled
        if (adoIntegration != null && adoIntegration.isEnabled()) {
            adoIntegration.updateStepResult(action, details, status);
        }
    }
    
    /**
     * Log validation with expected and actual values
     */
    public void logValidation(String description, String expected, String actual, String status) {
        String message = String.format("%s - Expected: [%s], Actual: [%s]", 
            description, expected, actual);
        
        logCustomStep("Validation", message, status);
    }
    
    /**
     * Log assertion with detailed information
     */
    public void logAssertion(String assertion, boolean result) {
        String status = result ? "PASS" : "FAIL";
        logCustomStep("Assertion", assertion, status);
    }
    
    /**
     * Start a new test section
     */
    public void startSection(String sectionName) {
        ExtentTest test = getCurrentTest();
        if (test != null) {
            ExtentTest node = test.createNode(sectionName);
            testMap.put(Thread.currentThread().getName() + "_node", node);
        }
        
        logger.info("=== {} ===", sectionName);
    }
    
    /**
     * End current test section
     */
    public void endSection() {
        testMap.remove(Thread.currentThread().getName() + "_node");
    }
    
    private Status mapStatus(String status) {
        switch (status.toUpperCase()) {
            case "PASS":
                return Status.PASS;
            case "FAIL":
                return Status.FAIL;
            case "WARN":
                return Status.WARNING;
            case "SKIP":
                return Status.SKIP;
            default:
                return Status.INFO;
        }
    }
    
    private ExtentTest getCurrentTest() {
        String threadName = Thread.currentThread().getName();
        
        // Check for node first
        ExtentTest node = testMap.get(threadName + "_node");
        if (node != null) {
            return node;
        }
        
        // Return test
        return testMap.get(threadName);
    }
    
    private String getCurrentTestName() {
        CSContext context = CSContext.getCurrentContext();
        return context.getCurrentTest();
    }
}
```

---

## 13. Test Execution Engine

### 13.1 Framework Runner Implementation

```java
@RunWith(CSFrameworkRunner.class)
public class CSFrameworkRunner extends BlockJUnit4ClassRunner {
    private static final CSLogger logger = CSLogger.getInstance();
    private static final AtomicBoolean initialized = new AtomicBoolean(false);
    
    public CSFrameworkRunner(Class<?> testClass) throws InitializationError {
        super(testClass);
        initializeFramework();
    }
    
    private void initializeFramework() {
        if (initialized.compareAndSet(false, true)) {
            logger.info("Initializing CS Framework Runner");
            
            try {
                // Initialize framework
                CSFramework.getInstance().initialize();
                
                // Register all listeners automatically
                registerListeners();
                
                // Setup reporting
                CSReportEngine.getInstance().initialize();
                
                // Setup parallel execution if enabled
                if (CSConfiguration.getInstance().getBoolean("cs.parallel.enabled", false)) {
                    setupParallelExecution();
                }
                
                logger.info("CS Framework Runner initialized successfully");
                
            } catch (Exception e) {
                logger.error("Failed to initialize framework runner", e);
                throw new RuntimeException("Framework initialization failed", e);
            }
        }
    }
    
    private void registerListeners() {
        TestNG testNG = TestNG.getDefault();
        
        // Core listeners - all registered automatically
        testNG.addListener(new CSTestListener());
        testNG.addListener(new CSReportListener());
        testNG.addListener(new CSScreenshotListener());
        testNG.addListener(new CSDataListener());
        testNG.addListener(new CSRetryListener());
        testNG.addListener(new CSParallelListener());
        testNG.addListener(new CSADOListener());
        
        // BDD listeners if BDD tests present
        if (hasBDDTests()) {
            testNG.addListener(new CSBDDListener());
            testNG.addListener(new CSCucumberReportListener());
        }
        
        logger.info("All framework listeners registered automatically");
    }
}
```

---

## 14. Parallel Execution Architecture

### 14.1 Parallel Engine Implementation

```java
public class CSParallelEngine {
    private static volatile CSParallelEngine instance;
    
    private final ExecutorService executorService;
    private final ThreadPoolExecutor threadPool;
    private final Map<String, Future<?>> runningTasks = new ConcurrentHashMap<>();
    private final CSConfiguration config;
    
    private CSParallelEngine() {
        this.config = CSConfiguration.getInstance();
        
        int threadCount = config.getInt("cs.parallel.thread.count", 5);
        
        this.threadPool = new ThreadPoolExecutor(
            threadCount,
            threadCount,
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(),
            new CSThreadFactory(),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        this.executorService = threadPool;
    }
    
    public static CSParallelEngine getInstance() {
        if (instance == null) {
            synchronized (CSParallelEngine.class) {
                if (instance == null) {
                    instance = new CSParallelEngine();
                }
            }
        }
        return instance;
    }
    
    public Future<TestResult> submitTest(Runnable test, String testName) {
        logger.info("Submitting test for parallel execution: {}", testName);
        
        Future<TestResult> future = executorService.submit(() -> {
            TestResult result = new TestResult(testName);
            
            try {
                // Initialize context for thread
                CSContext context = CSContext.getCurrentContext();
                context.setCurrentTest(testName);
                
                // Create driver for thread
                context.getDriver();
                
                // Run test
                result.setStartTime(LocalDateTime.now());
                test.run();
                result.setStatus(TestStatus.PASSED);
                
            } catch (Exception e) {
                logger.error("Test failed: {}", testName, e);
                result.setStatus(TestStatus.FAILED);
                result.setError(e);
            } finally {
                result.setEndTime(LocalDateTime.now());
                
                // Cleanup
                CSContext.getCurrentContext().cleanup();
            }
            
            return result;
        });
        
        runningTasks.put(testName, future);
        return future;
    }
}
```

---

## 15. Azure DevOps Integration

### 15.1 Azure DevOps Integration with Proxy Support

```java
public class CSAzureDevOpsIntegration {
    private final String organization;
    private final String project;
    private final String personalAccessToken;
    private final boolean enabled;
    private final CSAzureDevOpsClient client;
    private final CSLogger logger = CSLogger.getInstance();
    
    // Current test run context
    private String currentTestPlanId;
    private String currentTestSuiteId;
    private String currentTestRunId;
    private final Map<String, List<String>> testCaseMapping = new ConcurrentHashMap<>();
    
    public CSAzureDevOpsIntegration() {
        CSConfiguration config = CSConfiguration.getInstance();
        
        this.enabled = config.getBoolean("cs.ado.enabled", false);
        
        if (enabled) {
            this.organization = config.getString("cs.ado.organization");
            this.project = config.getString("cs.ado.project");
            this.personalAccessToken = CSSecretManager.decrypt(config.getString("cs.ado.pat"));
            
            // Create client with proxy configuration
            this.client = createClient(config);
            
            logger.info("Azure DevOps integration enabled for: {}/{}", organization, project);
        } else {
            this.client = null;
            logger.info("Azure DevOps integration is disabled");
        }
    }
    
    private CSAzureDevOpsClient createClient(CSConfiguration config) {
        CSAzureDevOpsClient.Builder builder = CSAzureDevOpsClient.builder()
            .organization(organization)
            .project(project)
            .personalAccessToken(personalAccessToken);
        
        // Configure proxy if enabled
        if (config.getBoolean("cs.proxy.enabled", false)) {
            String proxyHost = config.getString("cs.proxy.host");
            int proxyPort = config.getInt("cs.proxy.port", 8080);
            
            builder.proxyHost(proxyHost)
                   .proxyPort(proxyPort);
            
            // Proxy authentication if provided
            String proxyUser = config.getString("cs.proxy.username");
            String proxyPassword = CSSecretManager.decrypt(config.getString("cs.proxy.password"));
            if (proxyUser != null && proxyPassword != null) {
                builder.proxyCredentials(proxyUser, proxyPassword);
            }
        }
        
        return builder.build();
    }
    
    public void initialize(CSConfiguration config) {
        if (!enabled) return;
        
        // Load default test plan and suite from config
        this.currentTestPlanId = config.getString("cs.ado.testplan.id");
        this.currentTestSuiteId = config.getString("cs.ado.testsuite.id");
        
        // Create test run if auto-create is enabled
        if (config.getBoolean("cs.ado.auto.create.run", true)) {
            createTestRun();
        }
    }
    
    public boolean isEnabled() {
        return enabled;
    }
    
    /**
     * Override test plan ID from annotation
     */
    public void setTestPlanId(String testPlanId) {
        this.currentTestPlanId = testPlanId;
        logger.debug("Test Plan ID set to: {}", testPlanId);
    }
    
    /**
     * Override test suite ID from annotation
     */
    public void setTestSuiteId(String testSuiteId) {
        this.currentTestSuiteId = testSuiteId;
        logger.debug("Test Suite ID set to: {}", testSuiteId);
    }
    
    /**
     * Map scenario to multiple test case IDs
     */
    public void mapTestCases(String scenarioId, String testCaseIds) {
        if (!enabled) return;
        
        // Parse test case IDs: "{TC001, TC002, TC003}"
        String cleaned = testCaseIds.replaceAll("[{}\\s]", "");
        List<String> ids = Arrays.asList(cleaned.split(","));
        
        testCaseMapping.put(scenarioId, ids);
        logger.debug("Mapped scenario {} to test cases: {}", scenarioId, ids);
    }
    
    /**
     * Create a new test run
     */
    public void createTestRun() {
        if (!enabled) return;
        
        try {
            TestRun testRun = new TestRun();
            testRun.setName("Automated Test Run - " + LocalDateTime.now());
            testRun.setPlanId(currentTestPlanId);
            testRun.setAutomated(true);
            testRun.setBuildId(System.getenv("BUILD_BUILDID")); // Azure DevOps build ID
            
            TestRun createdRun = client.createTestRun(testRun);
            this.currentTestRunId = createdRun.getId();
            
            logger.info("Created test run: {}", currentTestRunId);
            
        } catch (Exception e) {
            logger.error("Failed to create test run", e);
        }
    }
    
    /**
     * Update test case result in Azure DevOps
     */
    public void updateTestCaseResult(String scenarioId, TestStatus status, String message) {
        if (!enabled || currentTestRunId == null) return;
        
        List<String> testCaseIds = testCaseMapping.get(scenarioId);
        if (testCaseIds == null || testCaseIds.isEmpty()) {
            logger.debug("No test cases mapped for scenario: {}", scenarioId);
            return;
        }
        
        // Update each mapped test case
        for (String testCaseId : testCaseIds) {
            try {
                TestCaseResult result = new TestCaseResult();
                result.setTestCaseId(testCaseId);
                result.setOutcome(mapStatus(status));
                result.setCompletedDate(LocalDateTime.now());
                
                if (message != null) {
                    result.setErrorMessage(message);
                }
                
                // Add test run context
                result.setTestRunId(currentTestRunId);
                result.setTestPlanId(currentTestPlanId);
                result.setTestSuiteId(currentTestSuiteId);
                
                client.updateTestResult(currentTestRunId, result);
                
                logger.debug("Updated test case {} with status: {}", testCaseId, status);
                
            } catch (Exception e) {
                logger.error("Failed to update test case: {}", testCaseId, e);
            }
        }
    }
    
    /**
     * Update step result (called from reporter)
     */
    public void updateStepResult(String action, String details, String status) {
        if (!enabled) return;
        
        // This can be extended to update step-level results in ADO if needed
        logger.debug("Step result: {} - {} [{}]", action, details, status);
    }
    
    /**
     * Upload test results and artifacts
     */
    public void uploadTestResults(String reportPath) {
        if (!enabled || currentTestRunId == null) return;
        
        try {
            // Upload HTML report
            File htmlReport = new File(reportPath, "index.html");
            if (htmlReport.exists()) {
                client.attachTestRunArtifact(currentTestRunId, htmlReport, "HTML Report");
            }
            
            // Upload screenshots
            File screenshotDir = new File(reportPath, "screenshots");
            if (screenshotDir.exists() && screenshotDir.isDirectory()) {
                for (File screenshot : screenshotDir.listFiles()) {
                    client.attachTestRunArtifact(currentTestRunId, screenshot, "Screenshot");
                }
            }
            
            logger.info("Uploaded test results to Azure DevOps");
            
        } catch (Exception e) {
            logger.error("Failed to upload test results", e);
        }
    }
    
    /**
     * Complete test run
     */
    public void completeTestRun() {
        if (!enabled || currentTestRunId == null) return;
        
        try {
            client.completeTestRun(currentTestRunId);
            logger.info("Completed test run: {}", currentTestRunId);
            
        } catch (Exception e) {
            logger.error("Failed to complete test run", e);
        }
    }
    
    private String mapStatus(TestStatus status) {
        switch (status) {
            case PASSED:
                return "Passed";
            case FAILED:
                return "Failed";
            case SKIPPED:
                return "NotExecuted";
            default:
                return "None";
        }
    }
}

// Azure DevOps Client
public class CSAzureDevOpsClient {
    private final String baseUrl;
    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;
    private final String authHeader;
    
    private CSAzureDevOpsClient(Builder builder) {
        this.baseUrl = String.format("https://dev.azure.com/%s/%s/_apis", 
            builder.organization, builder.project);
        
        // Configure HTTP client with proxy
        HttpClient.Builder clientBuilder = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(30));
        
        if (builder.proxyHost != null) {
            ProxySelector proxySelector = ProxySelector.of(
                new InetSocketAddress(builder.proxyHost, builder.proxyPort));
            clientBuilder.proxy(proxySelector);
            
            // Proxy authentication
            if (builder.proxyUser != null) {
                clientBuilder.authenticator(new Authenticator() {
                    @Override
                    protected PasswordAuthentication getPasswordAuthentication() {
                        return new PasswordAuthentication(
                            builder.proxyUser, 
                            builder.proxyPassword.toCharArray()
                        );
                    }
                });
            }
        }
        
        this.httpClient = clientBuilder.build();
        this.objectMapper = new ObjectMapper();
        
        // Basic auth header
        String credentials = ":" + builder.personalAccessToken;
        this.authHeader = "Basic " + Base64.getEncoder()
            .encodeToString(credentials.getBytes(StandardCharsets.UTF_8));
    }
    
    public TestRun createTestRun(TestRun testRun) throws IOException, InterruptedException {
        String json = objectMapper.writeValueAsString(testRun);
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/test/runs?api-version=6.0"))
            .header("Authorization", authHeader)
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(json))
            .build();
        
        HttpResponse<String> response = httpClient.send(request, 
            HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            throw new IOException("Failed to create test run: " + response.body());
        }
        
        return objectMapper.readValue(response.body(), TestRun.class);
    }
    
    public void updateTestResult(String testRunId, TestCaseResult result) 
            throws IOException, InterruptedException {
        String json = objectMapper.writeValueAsString(Arrays.asList(result));
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/test/runs/" + testRunId + "/results?api-version=6.0"))
            .header("Authorization", authHeader)
            .header("Content-Type", "application/json")
            .method("PATCH", HttpRequest.BodyPublishers.ofString(json))
            .build();
        
        HttpResponse<String> response = httpClient.send(request, 
            HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            throw new IOException("Failed to update test result: " + response.body());
        }
    }
    
    public void attachTestRunArtifact(String testRunId, File file, String description) 
            throws IOException, InterruptedException {
        // Implementation for attaching artifacts
    }
    
    public void completeTestRun(String testRunId) 
            throws IOException, InterruptedException {
        String json = "{\"state\":\"Completed\"}";
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/test/runs/" + testRunId + "?api-version=6.0"))
            .header("Authorization", authHeader)
            .header("Content-Type", "application/json")
            .method("PATCH", HttpRequest.BodyPublishers.ofString(json))
            .build();
        
        HttpResponse<String> response = httpClient.send(request, 
            HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            throw new IOException("Failed to complete test run: " + response.body());
        }
    }
    
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private String organization;
        private String project;
        private String personalAccessToken;
        private String proxyHost;
        private int proxyPort = 8080;
        private String proxyUser;
        private String proxyPassword;
        
        public Builder organization(String organization) {
            this.organization = organization;
            return this;
        }
        
        public Builder project(String project) {
            this.project = project;
            return this;
        }
        
        public Builder personalAccessToken(String pat) {
            this.personalAccessToken = pat;
            return this;
        }
        
        public Builder proxyHost(String proxyHost) {
            this.proxyHost = proxyHost;
            return this;
        }
        
        public Builder proxyPort(int proxyPort) {
            this.proxyPort = proxyPort;
            return this;
        }
        
        public Builder proxyCredentials(String user, String password) {
            this.proxyUser = user;
            this.proxyPassword = password;
            return this;
        }
        
        public CSAzureDevOpsClient build() {
            return new CSAzureDevOpsClient(this);
        }
    }
}
```

---

## 16. API Testing Framework

### 16.1 Native Java HTTP Client Implementation

```java
public class CSApiClient {
    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;
    private final CSLogger logger = CSLogger.getInstance();
    
    private CSApiClient() {
        // Configure HTTP client with proxy support
        HttpClient.Builder builder = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2)
            .connectTimeout(Duration.ofSeconds(30));
        
        // Configure proxy if enabled
        CSConfiguration config = CSConfiguration.getInstance();
        if (config.getBoolean("cs.proxy.enabled", false)) {
            ProxySelector proxySelector = ProxySelector.of(
                new InetSocketAddress(
                    config.getString("cs.proxy.host"),
                    config.getInt("cs.proxy.port", 8080)
                )
            );
            builder.proxy(proxySelector);
        }
        
        this.httpClient = builder.build();
        this.objectMapper = new ObjectMapper();
    }
    
    public static CSApiRequestBuilder given() {
        return new CSApiRequestBuilder(new CSApiClient());
    }
    
    public static class CSApiRequestBuilder {
        private final CSApiClient client;
        private String baseUri = "";
        private final Map<String, String> headers = new HashMap<>();
        private final Map<String, String> queryParams = new HashMap<>();
        private final Map<String, String> pathParams = new HashMap<>();
        private Object body;
        private CSApiResponse previousResponse; // For API chaining
        
        private CSApiRequestBuilder(CSApiClient client) {
            this.client = client;
            
            // Default headers
            headers.put("Accept", "application/json");
            headers.put("Content-Type", "application/json");
        }
        
        public CSApiRequestBuilder baseUri(String uri) {
            this.baseUri = uri;
            return this;
        }
        
        public CSApiRequestBuilder header(String name, String value) {
            headers.put(name, value);
            return this;
        }
        
        public CSApiRequestBuilder headers(Map<String, String> headers) {
            this.headers.putAll(headers);
            return this;
        }
        
        public CSApiRequestBuilder auth(String type, String credentials) {
            switch (type.toLowerCase()) {
                case "basic":
                    headers.put("Authorization", "Basic " + credentials);
                    break;
                case "bearer":
                    headers.put("Authorization", "Bearer " + credentials);
                    break;
                default:
                    headers.put("Authorization", credentials);
            }
            return this;
        }
        
        public CSApiRequestBuilder queryParam(String name, String value) {
            queryParams.put(name, value);
            return this;
        }
        
        public CSApiRequestBuilder pathParam(String name, String value) {
            pathParams.put(name, value);
            return this;
        }
        
        public CSApiRequestBuilder body(Object body) {
            this.body = body;
            return this;
        }
        
        // API Chaining - use value from previous response
        public String fromPreviousResponse(String jsonPath) {
            if (previousResponse != null) {
                Object value = previousResponse.jsonPath(jsonPath);
                if (value != null) {
                    return value.toString();
                }
            }
            throw new CSFrameworkException("No previous response available for chaining");
        }
        
        public CSApiRequestBuilder usePreviousResponse(CSApiResponse response) {
            this.previousResponse = response;
            return this;
        }
        
        // HTTP Methods
        
        public CSApiResponse get(String path) {
            return execute("GET", path, null);
        }
        
        public CSApiResponse post(String path) {
            return execute("POST", path, body);
        }
        
        public CSApiResponse put(String path) {
            return execute("PUT", path, body);
        }
        
        public CSApiResponse patch(String path) {
            return execute("PATCH", path, body);
        }
        
        public CSApiResponse delete(String path) {
            return execute("DELETE", path, null);
        }
        
        private CSApiResponse execute(String method, String path, Object requestBody) {
            try {
                // Build URL with path params
                String finalPath = path;
                for (Map.Entry<String, String> param : pathParams.entrySet()) {
                    finalPath = finalPath.replace("{" + param.getKey() + "}", param.getValue());
                }
                
                // Build URI with query params
                StringBuilder uriBuilder = new StringBuilder(baseUri + finalPath);
                if (!queryParams.isEmpty()) {
                    uriBuilder.append("?");
                    queryParams.forEach((k, v) -> 
                        uriBuilder.append(k).append("=").append(v).append("&"));
                    uriBuilder.deleteCharAt(uriBuilder.length() - 1);
                }
                
                URI uri = URI.create(uriBuilder.toString());
                
                // Build request
                HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                    .uri(uri)
                    .timeout(Duration.ofSeconds(30));
                
                // Add headers
                headers.forEach(requestBuilder::header);
                
                // Set method and body
                if (requestBody != null) {
                    String jsonBody = client.objectMapper.writeValueAsString(requestBody);
                    requestBuilder.method(method, HttpRequest.BodyPublishers.ofString(jsonBody));
                } else {
                    requestBuilder.method(method, HttpRequest.BodyPublishers.noBody());
                }
                
                HttpRequest request = requestBuilder.build();
                
                // Log request
                client.logger.info("API Request: {} {}", method, uri);
                client.logger.debug("Headers: {}", headers);
                if (requestBody != null) {
                    client.logger.debug("Body: {}", requestBody);
                }
                
                // Execute request
                HttpResponse<String> response = client.httpClient.send(request, 
                    HttpResponse.BodyHandlers.ofString());
                
                // Log response
                client.logger.info("API Response: {} - {}", 
                    response.statusCode(), 
                    response.statusCode() < 400 ? "Success" : "Failed");
                
                // Create response wrapper
                CSApiResponse apiResponse = new CSApiResponse(response, client.objectMapper);
                
                // Report to test report
                CSReportEngine.getInstance().logCustomStep(
                    "API Call",
                    String.format("%s %s - Status: %d", method, path, response.statusCode()),
                    response.statusCode() < 400 ? "PASS" : "FAIL"
                );
                
                return apiResponse;
                
            } catch (Exception e) {
                client.logger.error("API call failed", e);
                throw new CSApiException("API call failed: " + e.getMessage(), e);
            }
        }
    }
}

// API Response wrapper
public class CSApiResponse {
    private final HttpResponse<String> response;
    private final ObjectMapper objectMapper;
    private JsonNode jsonNode;
    
    public CSApiResponse(HttpResponse<String> response, ObjectMapper objectMapper) {
        this.response = response;
        this.objectMapper = objectMapper;
        
        // Parse JSON if response is JSON
        if (isJson()) {
            try {
                this.jsonNode = objectMapper.readTree(response.body());
            } catch (Exception e) {
                // Not valid JSON
            }
        }
    }
    
    public int getStatusCode() {
        return response.statusCode();
    }
    
    public String getBody() {
        return response.body();
    }
    
    public <T> T getBodyAs(Class<T> type) {
        try {
            return objectMapper.readValue(response.body(), type);
        } catch (Exception e) {
            throw new CSApiException("Failed to deserialize response body", e);
        }
    }
    
    public String getHeader(String name) {
        return response.headers().firstValue(name).orElse(null);
    }
    
    public Map<String, List<String>> getAllHeaders() {
        return response.headers().map();
    }
    
    // JSON Path support for API chaining
    public Object jsonPath(String path) {
        if (jsonNode == null) {
            throw new CSApiException("Response is not valid JSON");
        }
        
        // Simple JSON path implementation
        String[] parts = path.split("\\.");
        JsonNode current = jsonNode;
        
        for (String part : parts) {
            if (part.contains("[") && part.contains("]")) {
                // Array access
                String field = part.substring(0, part.indexOf("["));
                int index = Integer.parseInt(part.substring(part.indexOf("[") + 1, part.indexOf("]")));
                current = current.get(field).get(index);
            } else {
                current = current.get(part);
            }
            
            if (current == null) {
                return null;
            }
        }
        
        return current.asText();
    }
    
    // Validation methods
    
    public CSApiResponse assertStatusCode(int expected) {
        if (getStatusCode() != expected) {
            throw new AssertionError(String.format(
                "Expected status code %d but got %d", expected, getStatusCode()));
        }
        return this;
    }
    
    public CSApiResponse assertBodyContains(String expected) {
        if (!getBody().contains(expected)) {
            throw new AssertionError("Response body does not contain: " + expected);
        }
        return this;
    }
    
    public CSApiResponse assertJsonPath(String path, Object expected) {
        Object actual = jsonPath(path);
        if (!Objects.equals(expected, actual)) {
            throw new AssertionError(String.format(
                "JSON path %s: expected %s but got %s", path, expected, actual));
        }
        return this;
    }
    
    public CSApiResponse assertHeader(String name, String expected) {
        String actual = getHeader(name);
        if (!Objects.equals(expected, actual)) {
            throw new AssertionError(String.format(
                "Header %s: expected %s but got %s", name, expected, actual));
        }
        return this;
    }
    
    private boolean isJson() {
        String contentType = getHeader("Content-Type");
        return contentType != null && contentType.contains("application/json");
    }
}

// API Chaining Example
public class ApiChainingExample {
    
    public void testApiChaining() {
        // First API call - Login
        CSApiResponse loginResponse = CSApiClient.given()
            .baseUri("https://api.example.com")
            .body(Map.of("username", "user", "password", "pass"))
            .post("/auth/login")
            .assertStatusCode(200);
        
        // Extract token from response
        String token = (String) loginResponse.jsonPath("token");
        
        // Second API call - Use token from first response
        CSApiResponse userResponse = CSApiClient.given()
            .baseUri("https://api.example.com")
            .auth("bearer", token)
            .get("/users/profile")
            .assertStatusCode(200);
        
        // Third API call - Use data from second response
        String userId = (String) userResponse.jsonPath("id");
        
        CSApiResponse ordersResponse = CSApiClient.given()
            .baseUri("https://api.example.com")
            .auth("bearer", token)
            .pathParam("userId", userId)
            .get("/users/{userId}/orders")
            .assertStatusCode(200);
    }
}
```

---

## 17. Database Testing Support

### 17.1 Enhanced Database Testing Framework with Named Databases

```java
public class CSDatabaseManager {
    private static volatile CSDatabaseManager instance;
    private final Map<String, DataSource> dataSources = new ConcurrentHashMap<>();
    private final CSConfiguration config;
    private final CSLogger logger = CSLogger.getInstance();
    
    private CSDatabaseManager() {
        this.config = CSConfiguration.getInstance();
        initializeDataSources();
    }
    
    private void initializeDataSources() {
        // Scan configuration for database definitions
        // Pattern: {name}.db.enabled=true
        
        Set<String> databaseNames = findDatabaseNames();
        
        for (String dbName : databaseNames) {
            if (config.getBoolean(dbName + ".db.enabled", false)) {
                initializeDatabase(dbName);
            }
        }
    }
    
    private Set<String> findDatabaseNames() {
        Set<String> dbNames = new HashSet<>();
        
        // Find all properties ending with .db.enabled
        config.getAllKeys().stream()
            .filter(key -> key.endsWith(".db.enabled"))
            .map(key -> key.substring(0, key.indexOf(".db.enabled")))
            .forEach(dbNames::add);
        
        return dbNames;
    }
    
    private void initializeDatabase(String dbName) {
        try {
            String type = config.getString(dbName + ".db.type");
            
            HikariConfig hikariConfig = new HikariConfig();
            
            // Common settings
            hikariConfig.setJdbcUrl(config.getString(dbName + ".db.url"));
            hikariConfig.setUsername(config.getString(dbName + ".db.username"));
            hikariConfig.setPassword(CSSecretManager.decrypt(
                config.getString(dbName + ".db.password")));
            
            // Optional settings
            hikariConfig.setMaximumPoolSize(
                config.getInt(dbName + ".db.pool.size", 10));
            hikariConfig.setConnectionTimeout(
                config.getLong(dbName + ".db.connection.timeout", 30000));
            
            // Database type specific settings
            configureByType(hikariConfig, type);
            
            // Create data source
            DataSource dataSource = new HikariDataSource(hikariConfig);
            dataSources.put(dbName, dataSource);
            
            logger.info("Initialized database '{}' of type '{}'", dbName, type);
            
        } catch (Exception e) {
            logger.error("Failed to initialize database: {}", dbName, e);
        }
    }
    
    private void configureByType(HikariConfig config, String type) {
        switch (type.toLowerCase()) {
            case "mysql":
                config.setDriverClassName("com.mysql.cj.jdbc.Driver");
                ```java
                config.addDataSourceProperty("cachePrepStmts", "true");
                config.addDataSourceProperty("prepStmtCacheSize", "250");
                break;
                
            case "postgresql":
                config.setDriverClassName("org.postgresql.Driver");
                break;
                
            case "oracle":
                config.setDriverClassName("oracle.jdbc.OracleDriver");
                config.addDataSourceProperty("implicitCachingEnabled", "true");
                break;
                
            case "sqlserver":
                config.setDriverClassName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
                break;
                
            case "mongodb":
                // MongoDB requires different handling
                break;
        }
    }
    
    public static CSDatabaseManager getInstance() {
        if (instance == null) {
            synchronized (CSDatabaseManager.class) {
                if (instance == null) {
                    instance = new CSDatabaseManager();
                }
            }
        }
        return instance;
    }
    
    public CSDatabase getDatabase(String name) {
        DataSource dataSource = dataSources.get(name);
        if (dataSource == null) {
            throw new CSFrameworkException("Database not configured: " + name + 
                ". Please check your configuration properties.");
        }
        return new CSDatabase(name, dataSource);
    }
    
    // Get default database
    public CSDatabase getDatabase() {
        if (dataSources.size() == 1) {
            String defaultDb = dataSources.keySet().iterator().next();
            return getDatabase(defaultDb);
        }
        throw new CSFrameworkException(
            "Multiple databases configured. Please specify database name.");
    }
}

// Database wrapper class
public class CSDatabase {
    private final String name;
    private final DataSource dataSource;
    private final CSLogger logger = CSLogger.getInstance();
    
    CSDatabase(String name, DataSource dataSource) {
        this.name = name;
        this.dataSource = dataSource;
    }
    
    /**
     * Execute a query and return results
     */
    public List<Map<String, Object>> query(String sql, Object... params) {
        logger.info("Executing query on database '{}': {}", name, sql);
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            // Set parameters
            for (int i = 0; i < params.length; i++) {
                stmt.setObject(i + 1, params[i]);
            }
            
            // Execute query
            ResultSet rs = stmt.executeQuery();
            
            // Convert to list of maps
            List<Map<String, Object>> results = new ArrayList<>();
            ResultSetMetaData metadata = rs.getMetaData();
            int columnCount = metadata.getColumnCount();
            
            while (rs.next()) {
                Map<String, Object> row = new HashMap<>();
                for (int i = 1; i <= columnCount; i++) {
                    String columnName = metadata.getColumnName(i);
                    Object value = rs.getObject(i);
                    row.put(columnName, value);
                }
                results.add(row);
            }
            
            logger.info("Query returned {} rows", results.size());
            CSReportEngine.getInstance().logCustomStep(
                "Database Query", 
                String.format("Executed on '%s': %s - Returned %d rows", name, sql, results.size()), 
                "PASS"
            );
            
            return results;
            
        } catch (SQLException e) {
            logger.error("Query execution failed on database '{}'", name, e);
            CSReportEngine.getInstance().logCustomStep(
                "Database Query", 
                String.format("Failed on '%s': %s - %s", name, sql, e.getMessage()), 
                "FAIL"
            );
            throw new CSDatabaseException("Query execution failed", e);
        }
    }
    
    /**
     * Execute an update/insert/delete
     */
    public int update(String sql, Object... params) {
        logger.info("Executing update on database '{}': {}", name, sql);
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            // Set parameters
            for (int i = 0; i < params.length; i++) {
                stmt.setObject(i + 1, params[i]);
            }
            
            // Execute update
            int affected = stmt.executeUpdate();
            
            logger.info("Update affected {} rows", affected);
            CSReportEngine.getInstance().logCustomStep(
                "Database Update", 
                String.format("Executed on '%s': %s - Affected %d rows", name, sql, affected), 
                "PASS"
            );
            
            return affected;
            
        } catch (SQLException e) {
            logger.error("Update execution failed on database '{}'", name, e);
            CSReportEngine.getInstance().logCustomStep(
                "Database Update", 
                String.format("Failed on '%s': %s - %s", name, sql, e.getMessage()), 
                "FAIL"
            );
            throw new CSDatabaseException("Update execution failed", e);
        }
    }
    
    /**
     * Validate database state
     */
    public void assertRowExists(String table, String whereClause, Object... params) {
        String sql = "SELECT COUNT(*) as count FROM " + table + " WHERE " + whereClause;
        List<Map<String, Object>> results = query(sql, params);
        
        long count = (Long) results.get(0).get("count");
        if (count == 0) {
            throw new AssertionError("No rows found in " + table + " where " + whereClause);
        }
        
        CSReportEngine.getInstance().logValidation(
            "Database Row Exists",
            "Expected: Row exists",
            "Actual: " + count + " rows found",
            "PASS"
        );
    }
    
    /**
     * Validate column value
     */
    public void assertColumnValue(String table, String column, Object expected, 
                                  String whereClause, Object... params) {
        String sql = "SELECT " + column + " FROM " + table + " WHERE " + whereClause;
        List<Map<String, Object>> results = query(sql, params);
        
        if (results.isEmpty()) {
            throw new AssertionError("No rows found to validate");
        }
        
        Object actual = results.get(0).get(column);
        if (!Objects.equals(expected, actual)) {
            CSReportEngine.getInstance().logValidation(
                "Database Column Value",
                expected.toString(),
                actual != null ? actual.toString() : "null",
                "FAIL"
            );
            throw new AssertionError(String.format(
                "Column %s: expected %s but got %s", column, expected, actual));
        }
        
        CSReportEngine.getInstance().logValidation(
            "Database Column Value",
            expected.toString(),
            actual.toString(),
            "PASS"
        );
    }
    
    /**
     * Execute stored procedure
     */
    public List<Map<String, Object>> callProcedure(String procedureName, Object... params) {
        String sql = "{call " + procedureName + "(" + 
            String.join(",", Collections.nCopies(params.length, "?")) + ")}";
        
        logger.info("Calling stored procedure on database '{}': {}", name, procedureName);
        
        try (Connection conn = dataSource.getConnection();
             CallableStatement stmt = conn.prepareCall(sql)) {
            
            // Set parameters
            for (int i = 0; i < params.length; i++) {
                stmt.setObject(i + 1, params[i]);
            }
            
            // Execute procedure
            boolean hasResults = stmt.execute();
            
            List<Map<String, Object>> results = new ArrayList<>();
            
            if (hasResults) {
                ResultSet rs = stmt.getResultSet();
                ResultSetMetaData metadata = rs.getMetaData();
                int columnCount = metadata.getColumnCount();
                
                while (rs.next()) {
                    Map<String, Object> row = new HashMap<>();
                    for (int i = 1; i <= columnCount; i++) {
                        String columnName = metadata.getColumnName(i);
                        Object value = rs.getObject(i);
                        row.put(columnName, value);
                    }
                    results.add(row);
                }
            }
            
            logger.info("Procedure returned {} rows", results.size());
            return results;
            
        } catch (SQLException e) {
            logger.error("Procedure execution failed on database '{}'", name, e);
            throw new CSDatabaseException("Procedure execution failed", e);
        }
    }
}

// Usage Examples
public class DatabaseTestExamples {
    
    @Test
    public void testMultipleDatabases() {
        // Get specific databases
        CSDatabase myappDb = CSDatabaseManager.getInstance().getDatabase("myapp");
        CSDatabase analyticsDb = CSDatabaseManager.getInstance().getDatabase("analytics");
        CSDatabase legacyDb = CSDatabaseManager.getInstance().getDatabase("legacy");
        
        // Query main application database
        List<Map<String, Object>> users = myappDb.query(
            "SELECT * FROM users WHERE status = ?", "ACTIVE");
        
        // Query analytics database
        List<Map<String, Object>> metrics = analyticsDb.query(
            "SELECT COUNT(*) as user_count, DATE(created_at) as date " +
            "FROM user_metrics WHERE created_at > ?", 
            LocalDate.now().minusDays(7)
        );
        
        // Update legacy database
        int updated = legacyDb.update(
            "UPDATE legacy_users SET last_sync = ? WHERE id = ?",
            LocalDateTime.now(), userId
        );
        
        // Validate across databases
        myappDb.assertRowExists("users", "email = ?", "test@example.com");
        analyticsDb.assertColumnValue("user_metrics", "status", "PROCESSED",
            "user_id = ?", userId);
    }
    
    @Test
    @CSDataSource("type=database, name=myapp, queryKey=query.users.active")
    public void testWithDatabaseData(Map<String, String> userData) {
        // Test will run for each row returned by query
        String username = userData.get("username");
        String role = userData.get("role");
        
        // Perform test with database data
        LoginPage loginPage = new LoginPage();
        loginPage.login(username, userData.get("password"));
        
        DashboardPage dashboard = new DashboardPage();
        dashboard.assertUserRole(role);
    }
}
```

---

## 18. Intelligence & Self-Healing

### 18.1 Enhanced Self-Healing Implementation

```java
public class CSElementHealer {
    private final CSDriver driver;
    private final CSConfiguration config;
    private final Map<String, HealingRecord> healingHistory = new ConcurrentHashMap<>();
    private final CSLogger logger = CSLogger.getInstance();
    
    public CSElementHealer(CSDriver driver) {
        this.driver = driver;
        this.config = CSConfiguration.getInstance();
    }
    
    public WebElement healElement(By originalLocator, String descriptionText) {
        logger.info("Attempting to heal element: {}", descriptionText);
        
        // Strategy 1: Try variations of the original locator
        List<By> variations = generateLocatorVariations(originalLocator);
        for (By variation : variations) {
            try {
                CSElement element = driver.findElement(variation);
                if (element.isDisplayed()) {
                    recordHealing(originalLocator, variation, "Locator Variation");
                    return element.getSeleniumElement();
                }
            } catch (Exception ignored) {
                // Try next variation
            }
        }
        
        // Strategy 2: Text-based search
        if (descriptionText != null && !descriptionText.isEmpty()) {
            WebElement healed = findByDescription(descriptionText);
            if (healed != null) {
                recordHealing(originalLocator, null, "Description-based");
                return healed;
            }
        }
        
        // Strategy 3: Visual similarity
        WebElement similar = findSimilarElement(originalLocator, descriptionText);
        if (similar != null) {
            recordHealing(originalLocator, null, "Visual Similarity");
            return similar;
        }
        
        // Strategy 4: DOM structure analysis
        WebElement structural = findByStructure(originalLocator);
        if (structural != null) {
            recordHealing(originalLocator, null, "DOM Structure");
            return structural;
        }
        
        throw new CSElementException("Failed to heal element: " + descriptionText);
    }
    
    private List<By> generateLocatorVariations(By originalLocator) {
        List<By> variations = new ArrayList<>();
        String locatorString = originalLocator.toString();
        
        if (locatorString.contains("By.id:")) {
            String id = extractValue(locatorString, "By.id:");
            
            // Try partial ID matches
            variations.add(By.cssSelector("[id*='" + id + "']"));
            variations.add(By.xpath("//*[contains(@id, '" + id + "')]"));
            
            // Try without numbers
            String idWithoutNumbers = id.replaceAll("\\d", "");
            if (!idWithoutNumbers.equals(id)) {
                variations.add(By.cssSelector("[id*='" + idWithoutNumbers + "']"));
            }
            
            // Try different cases
            variations.add(By.cssSelector("[id*='" + id.toLowerCase() + "']"));
            variations.add(By.cssSelector("[id*='" + id.toUpperCase() + "']"));
        }
        
        if (locatorString.contains("By.className:")) {
            String className = extractValue(locatorString, "By.className:");
            
            // Try partial class matches
            variations.add(By.cssSelector("[class*='" + className + "']"));
            variations.add(By.xpath("//*[contains(@class, '" + className + "')]"));
        }
        
        if (locatorString.contains("By.name:")) {
            String name = extractValue(locatorString, "By.name:");
            
            // Try different attribute combinations
            variations.add(By.cssSelector("[name*='" + name + "']"));
            variations.add(By.cssSelector("[data-name='" + name + "']"));
            variations.add(By.cssSelector("[aria-label*='" + name + "']"));
        }
        
        return variations;
    }
    
    private WebElement findByDescription(String description) {
        // Strategy 1: Find by text content
        List<String> xpaths = Arrays.asList(
            "//*[text()='" + description + "']",
            "//*[contains(text(), '" + description + "')]",
            "//button[contains(., '" + description + "')]",
            "//a[contains(., '" + description + "')]",
            "//input[@placeholder='" + description + "']",
            "//input[@value='" + description + "']",
            "//*[@aria-label='" + description + "']",
            "//*[@title='" + description + "']"
        );
        
        for (String xpath : xpaths) {
            try {
                List<CSElement> elements = driver.findElements(By.xpath(xpath));
                if (!elements.isEmpty()) {
                    // Return the first visible element
                    for (CSElement element : elements) {
                        if (element.isDisplayed()) {
                            logger.info("Found element by description using: {}", xpath);
                            return element.getSeleniumElement();
                        }
                    }
                }
            } catch (Exception ignored) {
                // Try next xpath
            }
        }
        
        return null;
    }
    
    private WebElement findSimilarElement(By originalLocator, String description) {
        // Get all elements of similar type
        String tagName = guessTagName(originalLocator, description);
        List<CSElement> candidates = driver.findElements(By.tagName(tagName));
        
        WebElement bestMatch = null;
        double bestScore = 0.0;
        
        for (CSElement candidate : candidates) {
            if (!candidate.isDisplayed()) continue;
            
            double score = calculateSimilarityScore(candidate, originalLocator, description);
            if (score > bestScore && score > 0.7) { // 70% threshold
                bestScore = score;
                bestMatch = candidate.getSeleniumElement();
            }
        }
        
        if (bestMatch != null) {
            logger.info("Found similar element with {}% confidence", bestScore * 100);
        }
        
        return bestMatch;
    }
    
    private double calculateSimilarityScore(CSElement element, By originalLocator, String description) {
        double score = 0.0;
        int factors = 0;
        
        // Check text similarity
        String elementText = element.getText();
        if (elementText != null && !elementText.isEmpty() && description != null) {
            double textSimilarity = calculateTextSimilarity(elementText, description);
            score += textSimilarity * 0.3;
            factors++;
        }
        
        // Check attribute similarity
        String[] attributes = {"id", "name", "class", "placeholder", "value", "aria-label"};
        for (String attr : attributes) {
            String value = element.getAttribute(attr);
            if (value != null && !value.isEmpty()) {
                if (originalLocator.toString().contains(value) || 
                    (description != null && description.contains(value))) {
                    score += 0.1;
                    factors++;
                }
            }
        }
        
        // Check position (prefer elements in similar screen location)
        // This would require storing original element position
        
        // Check CSS classes
        String classes = element.getAttribute("class");
        if (classes != null) {
            String[] classArray = classes.split("\\s+");
            for (String cls : classArray) {
                if (originalLocator.toString().contains(cls)) {
                    score += 0.1;
                    factors++;
                }
            }
        }
        
        return factors > 0 ? score / factors : 0.0;
    }
    
    private double calculateTextSimilarity(String text1, String text2) {
        // Simple similarity calculation (can be enhanced with better algorithms)
        text1 = text1.toLowerCase().trim();
        text2 = text2.toLowerCase().trim();
        
        if (text1.equals(text2)) return 1.0;
        if (text1.contains(text2) || text2.contains(text1)) return 0.8;
        
        // Calculate word overlap
        Set<String> words1 = new HashSet<>(Arrays.asList(text1.split("\\s+")));
        Set<String> words2 = new HashSet<>(Arrays.asList(text2.split("\\s+")));
        
        Set<String> intersection = new HashSet<>(words1);
        intersection.retainAll(words2);
        
        Set<String> union = new HashSet<>(words1);
        union.addAll(words2);
        
        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();
    }
    
    private void recordHealing(By originalLocator, By healedLocator, String strategy) {
        HealingRecord record = new HealingRecord(originalLocator, healedLocator, strategy);
        healingHistory.put(originalLocator.toString(), record);
        
        logger.info("Healing successful using strategy: {}", strategy);
        CSReportEngine.getInstance().logCustomStep(
            "Self-Healing",
            String.format("Healed element using %s strategy", strategy),
            "PASS"
        );
    }
    
    private String guessTagName(By locator, String description) {
        String locatorStr = locator.toString().toLowerCase();
        String descStr = description != null ? description.toLowerCase() : "";
        
        if (locatorStr.contains("button") || descStr.contains("button") || 
            descStr.contains("click")) {
            return "button";
        }
        if (locatorStr.contains("input") || descStr.contains("enter") || 
            descStr.contains("type")) {
            return "input";
        }
        if (locatorStr.contains("link") || locatorStr.contains("href")) {
            return "a";
        }
        if (locatorStr.contains("select") || descStr.contains("dropdown")) {
            return "select";
        }
        
        return "div"; // Default
    }
    
    private WebElement findByStructure(By originalLocator) {
        // Implement DOM structure analysis
        // This could analyze parent/sibling relationships
        // and find elements in similar DOM positions
        return null; // Placeholder
    }
    
    private String extractValue(String locatorString, String prefix) {
        int start = locatorString.indexOf(prefix) + prefix.length();
        int end = locatorString.indexOf("]", start);
        if (end == -1) end = locatorString.length();
        return locatorString.substring(start, end).trim();
    }
}

// Healing Record for tracking
class HealingRecord {
    private final By originalLocator;
    private final By healedLocator;
    private final String strategy;
    private final LocalDateTime timestamp;
    private int usageCount;
    
    public HealingRecord(By original, By healed, String strategy) {
        this.originalLocator = original;
        this.healedLocator = healed;
        this.strategy = strategy;
        this.timestamp = LocalDateTime.now();
        this.usageCount = 1;
    }
    
    public void incrementUsage() {
        usageCount++;
    }
    
    // Getters...
}
```

---

## 19. Logging & Monitoring

### 19.1 Enhanced Logging System

```java
public class CSLogger {
    private static final Map<String, CSLogger> loggers = new ConcurrentHashMap<>();
    private final Logger slf4jLogger;
    private final String loggerName;
    
    private CSLogger(String name) {
        this.loggerName = name;
        this.slf4jLogger = LoggerFactory.getLogger(name);
    }
    
    public static CSLogger getInstance() {
        return getInstance("CS.Framework");
    }
    
    public static CSLogger getInstance(Class<?> clazz) {
        return getInstance(clazz.getName());
    }
    
    public static CSLogger getInstance(String name) {
        return loggers.computeIfAbsent(name, CSLogger::new);
    }
    
    // Enhanced logging methods with context
    
    public void info(String message, Object... args) {
        if (slf4jLogger.isInfoEnabled()) {
            slf4jLogger.info(enhanceMessage(message), args);
        }
    }
    
    public void debug(String message, Object... args) {
        if (slf4jLogger.isDebugEnabled()) {
            slf4jLogger.debug(enhanceMessage(message), args);
        }
    }
    
    public void warn(String message, Object... args) {
        if (slf4jLogger.isWarnEnabled()) {
            slf4jLogger.warn(enhanceMessage(message), args);
        }
    }
    
    public void error(String message, Object... args) {
        slf4jLogger.error(enhanceMessage(message), args);
    }
    
    public void error(String message, Throwable throwable) {
        slf4jLogger.error(enhanceMessage(message), throwable);
    }
    
    private String enhanceMessage(String message) {
        CSContext context = CSContext.getCurrentContext();
        
        StringBuilder enhanced = new StringBuilder();
        
        // Add thread info
        enhanced.append("[").append(Thread.currentThread().getName()).append("] ");
        
        // Add test context if available
        if (context.getCurrentTest() != null) {
            enhanced.append("[").append(context.getCurrentTest()).append("] ");
        }
        
        enhanced.append(message);
        
        return enhanced.toString();
    }
}
```

---

## 20. Exception Handling Strategy

### 20.1 Custom Exception Hierarchy

```java
// Base Framework Exception
public class CSFrameworkException extends RuntimeException {
    private final String errorCode;
    private final Map<String, Object> context;
    private final LocalDateTime timestamp;
    
    public CSFrameworkException(String message) {
        this(null, message, null, new HashMap<>());
    }
    
    public CSFrameworkException(String message, Throwable cause) {
        this(null, message, cause, new HashMap<>());
    }
    
    public CSFrameworkException(String errorCode, String message, Throwable cause, Map<String, Object> context) {
        super(message, cause);
        this.errorCode = errorCode;
        this.context = context;
        this.timestamp = LocalDateTime.now();
        
        // Log exception
        logException();
    }
    
    private void logException() {
        CSLogger logger = CSLogger.getInstance();
        logger.error("Framework Exception: {} - {}", errorCode, getMessage(), this);
        
        if (!context.isEmpty()) {
            logger.error("Exception Context: {}", context);
        }
    }
    
    public CSFrameworkException withContext(String key, Object value) {
        context.put(key, value);
        return this;
    }
}

// Specific Exceptions
public class CSElementException extends CSFrameworkException {
    public CSElementException(String message) {
        super("ELEMENT_ERROR", message, null, new HashMap<>());
    }
    
    public CSElementException(String message, Throwable cause) {
        super("ELEMENT_ERROR", message, cause, new HashMap<>());
    }
}

public class CSDriverException extends CSFrameworkException {
    public CSDriverException(String message) {
        super("DRIVER_ERROR", message, null, new HashMap<>());
    }
    
    public CSDriverException(String message, Throwable cause) {
        super("DRIVER_ERROR", message, cause, new HashMap<>());
    }
}

public class CSDataException extends CSFrameworkException {
    public CSDataException(String message) {
        super("DATA_ERROR", message, null, new HashMap<>());
    }
    
    public CSDataException(String message, Throwable cause) {
        super("DATA_ERROR", message, cause, new HashMap<>());
    }
}

public class CSConfigurationException extends CSFrameworkException {
    public CSConfigurationException(String message) {
        super("CONFIG_ERROR", message, null, new HashMap<>());
    }
}

public class CSApiException extends CSFrameworkException {
    public CSApiException(String message) {
        super("API_ERROR", message, null, new HashMap<>());
    }
    
    public CSApiException(String message, Throwable cause) {
        super("API_ERROR", message, cause, new HashMap<>());
    }
}

public class CSDatabaseException extends CSFrameworkException {
    public CSDatabaseException(String message) {
        super("DATABASE_ERROR", message, null, new HashMap<>());
    }
    
    public CSDatabaseException(String message, Throwable cause) {
        super("DATABASE_ERROR", message, cause, new HashMap<>());
    }
}
```

---

## 21. Framework Packaging & Distribution

### 21.1 Maven Configuration

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.cs</groupId>
    <artifactId>cs-framework</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <name>CS Framework</name>
    <description>Enterprise Test Automation Framework</description>
    
    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        
        <!-- Dependency versions -->
        <selenium.version>4.15.0</selenium.version>
        <testng.version>7.8.0</testng.version>
        <cucumber.version>7.14.0</cucumber.version>
        <extentreports.version>5.1.1</extentreports.version>
        <slf4j.version>2.0.9</slf4j.version>
        <logback.version>1.4.11</logback.version>
        <jackson.version>2.15.3</jackson.version>
        <poi.version>5.2.4</poi.version>
        <hikaricp.version>5.1.0</hikaricp.version>
        <opencsv.version>5.8</opencsv.version>
        <commons-lang3.version>3.13.0</commons-lang3.version>
        <commons-io.version>2.15.0</commons-io.version>
    </properties>
    
    <dependencies>
        <!-- Selenium -->
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-java</artifactId>
            <version>${selenium.version}</version>
        </dependency>
        
        <!-- WebDriverManager -->
        <dependency>
            <groupId>io.github.bonigarcia</groupId>
            <artifactId>webdrivermanager</artifactId>
            <version>5.6.2</version>
        </dependency>
        
        <!-- TestNG -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>${testng.version}</version>
        </dependency>
        
        <!-- Cucumber -->
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-java</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-testng</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        
        <!-- ExtentReports -->
        <dependency>
            <groupId>com.aventstack</groupId>
            <artifactId>extentreports</artifactId>
            <version>${extentreports.version}</version>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        
        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        
        <!-- JSON Path -->
        <dependency>
            <groupId>com.jayway.jsonpath</groupId>
            <artifactId>json-path</artifactId>
            <version>2.8.0</version>
        </dependency>
        
        <!-- Excel Processing -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>${poi.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>${poi.version}</version>
        </dependency>
        
        <!-- CSV Processing -->
        <dependency>
            <groupId>com.opencsv</groupId>
            <artifactId>opencsv</artifactId>
            <version>${opencsv.version}</version>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>${hikaricp.version}</version>
        </dependency>
        
        <!-- Database Drivers -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.33</version>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.6.0</version>
        </dependency>
        
        <!-- Utilities -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <!-- Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                </configuration>
            </plugin>
            
            <!-- JAR Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
                            <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
            
            <!-- Source Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>3.3.0</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Javadoc Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>3.6.0</version>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        
        <!-- Resources -->
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                    <include>**/*.json</include>
                </includes>
            </resource>
        </resources>
    </build>
</project>
```

---

## 22. Implementation Roadmap

### Phase 1: Core Framework (Weeks 1-2)
- [x] Design complete architecture
- [ ] Implement CSFramework main controller
- [ ] Implement CSContext with thread-local storage
- [ ] Implement hierarchical configuration system
- [ ] Implement SQL query manager
- [ ] Implement object repository
- [ ] Implement simple secret management
- [ ] Basic logging infrastructure
- [ ] Create Maven project structure

### Phase 2: Driver & Element Management (Weeks 3-4)
- [ ] Implement CSDriver wrapper interface
- [ ] Implement CSDriverManager with browser support
- [ ] Implement comprehensive CSElement class
- [ ] Implement smart wait strategies
- [ ] Implement browser capability management
- [ ] Add proxy configuration support
- [ ] Implement self-healing elements with alternative locator support

### Phase 3: Page Object & BDD (Weeks 5-6)
- [ ] Implement dynamic page object base
- [ ] Implement page factory with element initialization
- [ ] Implement unified @CSBDDStep annotation
- [ ] Implement step matcher and executor
- [ ] Implement enhanced data source integration
- [ ] Add SQL query key support for database data sources

### Phase 4: Advanced Features (Weeks 7-8)
- [ ] Implement self-healing elements with AI
- [ ] Implement parallel execution engine
- [ ] Implement comprehensive reporting
- [ ] Implement Azure DevOps integration
- [ ] Implement API testing with native HTTP client
- [ ] Implement database testing support with named databases
- [ ] Implement comprehensive utility classes

### Phase 5: Testing & Documentation (Weeks 9-10)
- [ ] Unit tests for all components
- [ ] Integration tests
- [ ] Performance testing
- [ ] User documentation
- [ ] API documentation
- [ ] Sample project with all features
- [ ] Publishing to Maven repository

### Development Guidelines

1. **Code Standards**
   - No direct Selenium exposure in public APIs
   - All methods must have JavaDoc
   - Follow SOLID principles
   - Maintain high cohesion, low coupling

2. **Testing Requirements**
   - Minimum 80% code coverage
   - Unit tests for all public methods
   - Integration tests for workflows
   - Performance benchmarks

3. **Documentation**
   - API documentation
   - User guides with examples
   - Migration guide from Selenium
   - Troubleshooting guide
   - Configuration guide

4. **Quality Gates**
   - Static code analysis (SonarQube)
   - Security scanning
   - Performance profiling
   - Cross-browser testing

### Success Criteria

1. **Framework Usability**
   - Zero Selenium imports in user code
   - Intuitive API design
   - Comprehensive error messages
   - Rich documentation
   - Easy configuration

2. **Performance**
   - Minimal overhead over raw Selenium
   - Efficient resource usage
   - Fast test execution
   - Scalable parallel execution

3. **Reliability**
   - Stable self-healing
   - Robust error handling
   - Consistent behavior
   - Comprehensive logging
   - Reliable utility methods

4. **Integration**
   - Seamless Azure DevOps integration
   - Easy Maven dependency usage
   - Configuration flexibility
   - Extensibility points
   - Multiple database support

---

## 23. Complete Usage Examples

### 23.1 Application Properties Configuration

```properties
# application.properties - Main configuration file

# Framework Configuration
cs.framework.name=MyApp Test Automation
cs.environment=qa

# Configuration File Locations
cs.config.sql.queries=config/SqlQueries.properties
cs.config.object.repository=config/object-repository.properties
cs.config.test.data=config/test-data.properties
cs.config.api.endpoints=config/api-endpoints.properties

# Driver Configuration
cs.driver.browser=chrome
cs.driver.type=local
cs.driver.headless=false
cs.driver.maximize=true
cs.driver.implicitWait=10
cs.driver.explicitWait=30
cs.driver.pageLoadTimeout=60
cs.driver.clean.session=true

# Browser Specific Additional Capabilities
# Chrome
chrome.additional.capabilities.args.disable-gpu=true
chrome.additional.capabilities.args.no-sandbox=true
chrome.additional.capabilities.args.disable-dev-shm-usage=true
chrome.additional.capabilities.args.window-size=1920,1080
chrome.additional.capabilities.prefs.download.default_directory=./downloads
chrome.additional.capabilities.prefs.download.prompt_for_download=false
chrome.additional.capabilities.prefs.plugins.always_open_pdf_externally=true

# Firefox
firefox.additional.capabilities.args.width=1920
firefox.additional.capabilities.args.height=1080
firefox.additional.capabilities.prefs.browser.download.dir=./downloads
firefox.additional.capabilities.prefs.browser.download.folderList=2
firefox.additional.capabilities.prefs.browser.helperApps.neverAsk.saveToDisk=application/pdf,text/csv

# Edge
edge.additional.capabilities.args.start-maximized=true
edge.additional.capabilities.prefs.download.default_directory=./downloads

# Wait Configuration
cs.wait.timeout=30
cs.wait.polling=500

# Screenshot Configuration
cs.screenshot.on.failure=true
cs.screenshot.on.step=false
cs.screenshot.format=png
cs.screenshot.directory=test-output/screenshots

# Report Configuration
cs.report.enabled=true
cs.report.directory=test-output/reports
cs.report.format=html,json,pdf
cs.report.dashboard=true
cs.report.realtime=false

# Parallel Execution
cs.parallel.enabled=true
cs.parallel.thread.count=5
cs.parallel.strategy=methods

# Proxy Configuration (if behind corporate proxy)
cs.proxy.enabled=true
cs.proxy.host=proxy.mycompany.com
cs.proxy.port=8080
cs.proxy.username=proxyuser
cs.proxy.password=ENC(AfD3Kf9LkdmN...)
cs.proxy.no.proxy=localhost,127.0.0.1,*.mycompany.local

# Azure DevOps Integration
cs.ado.enabled=true
cs.ado.organization=mycompany
cs.ado.project=TestAutomation
cs.ado.pat=ENC(BgE4Lg0MleO8...)
cs.ado.testplan.id=12345
cs.ado.testsuite.id=67890
cs.ado.auto.create.run=true

# Application URLs
app.base.url=https://myapp-qa.company.com
app.api.base.url=https://api-qa.company.com/v1
app.admin.url=https://admin-qa.company.com

# Test Users
test.user.admin.username=admin@company.com
test.user.admin.password=ENC(ChF5Mh1NmfP9...)
test.user.standard.username=user@company.com
test.user.standard.password=ENC(DiG6Ni2OnqA0...)

# Database Configurations - Named Database Support
# Primary Application Database
myapp.db.enabled=true
myapp.db.type=mysql
myapp.db.host=qa-db.company.com
myapp.db.port=3306
myapp.db.name=myapp_qa
myapp.db.url=jdbc:mysql://qa-db.company.com:3306/myapp_qa
myapp.db.username=qa_user
myapp.db.password=ENC(EjH7Oj3PoRB1...)
myapp.db.connection.timeout=5000
myapp.db.pool.size=10

# Analytics Database
analytics.db.enabled=true
analytics.db.type=postgresql
analytics.db.host=analytics-qa.company.com
analytics.db.port=5432
analytics.db.name=analytics
analytics.db.url=jdbc:postgresql://analytics-qa.company.com:5432/analytics
analytics.db.username=analytics_reader
analytics.db.password=ENC(FkI8Pk4QpSC2...)

# Legacy System Database
legacy.db.enabled=true
legacy.db.type=oracle
legacy.db.host=legacy-qa.company.com
legacy.db.port=1521
legacy.db.sid=LEGACYQA
legacy.db.url=jdbc:oracle:thin:@legacy-qa.company.com:1521:LEGACYQA
legacy.db.username=legacy_user
legacy.db.password=ENC(GlJ9Ql5RqTD3...)

# MongoDB Configuration
mongo.db.enabled=true
mongo.db.type=mongodb
mongo.db.connection.string=mongodb://qa-mongo.company.com:27017/myapp
mongo.db.database=myapp
mongo.db.username=mongo_user
mongo.db.password=ENC(HmKARm6SrUE4...)

# API Configuration
api.auth.type=oauth2
api.auth.token.url=https://auth-qa.company.com/oauth/token
api.auth.client.id=test-automation-client
api.auth.client.secret=ENC(InLBSn7TsVF5...)
api.timeout=30000
api.retry.count=3
api.retry.delay=1000

# Custom Application Properties
app.default.language=en
app.supported.languages=en,es,fr,de
app.max.upload.size=10485760
app.session.timeout=1800
```

### 23.2 SQL Queries Properties

```properties
# SqlQueries.properties - Centralized SQL query management

# User queries
query.users.active=SELECT username, password, role FROM test_users WHERE active = 1
query.users.by.role=SELECT * FROM test_users WHERE role = ? AND active = 1
query.users.login.validation=SELECT id, username, role, last_login FROM users WHERE username = ? AND password = ?
query.users.recent.registrations=SELECT * FROM users WHERE created_date > ? ORDER BY created_date DESC

# Product queries
query.products.by.category=SELECT * FROM products WHERE category = ? AND status = 'ACTIVE'
query.products.search=SELECT * FROM products WHERE name LIKE ? OR description LIKE ?
query.products.inventory=SELECT p.*, i.quantity FROM products p JOIN inventory i ON p.id = i.product_id
query.products.low.stock=SELECT * FROM products p JOIN inventory i ON p.id = i.product_id WHERE i.quantity < ?

# Order queries
query.orders.recent=SELECT * FROM orders WHERE created_date > ? ORDER BY created_date DESC
query.orders.by.status=SELECT * FROM orders WHERE status = ? AND user_id = ?
query.orders.summary=SELECT COUNT(*) as order_count, SUM(total_amount) as total_revenue FROM orders WHERE order_date BETWEEN ? AND ?

# Analytics queries
query.analytics.daily.revenue=SELECT DATE(order_date) as date, SUM(total_amount) as revenue FROM orders WHERE order_date BETWEEN ? AND ? GROUP BY DATE(order_date)
query.analytics.user.activity=SELECT user_id, COUNT(*) as activity_count FROM user_activities WHERE activity_date > ? GROUP BY user_id
query.analytics.product.performance=SELECT p.name, COUNT(oi.product_id) as sales_count, SUM(oi.quantity) as total_quantity FROM order_items oi JOIN products p ON oi.product_id = p.id GROUP BY p.id

# Test data queries
query.test.data.users=SELECT * FROM test_users WHERE environment = ? AND status = 'ACTIVE'
query.test.data.products=SELECT * FROM test_products WHERE category = ? AND test_flag = 1
query.test.data.scenarios=SELECT * FROM test_scenarios WHERE feature = ? AND enabled = 1
```

### 23.3 Object Repository Properties

```properties
# object-repository.properties

# Login Page
login.username.field=id:username
login.password.field=id:password
login.submit.button=css:button[type='submit']
login.submit.button.xpath=xpath://button[contains(text(),'Sign In')]
login.submit.button.alt1=css:.login-btn
login.remember.checkbox=id:rememberMe
login.forgot.password.link=xpath://a[contains(text(),'Forgot Password')]
login.error.message=css:.error-message
login.success.message=css:.success-message

# Dashboard Page
dashboard.welcome.message=css:.welcome-message
dashboard.user.menu=id:userMenu
dashboard.logout.link=id:logout
dashboard.search.box=css:input[placeholder='Search']
dashboard.notification.icon=css:.notification-icon
dashboard.notification.count=css:.notification-count

# Navigation Menu
nav.home=xpath://nav//a[text()='Home']
nav.products=xpath://nav//a[text()='Products']
nav.orders=xpath://nav//a[text()='Orders']
nav.customers=xpath://nav//a[text()='Customers']
nav.reports=xpath://nav//a[text()='Reports']
nav.settings=xpath://nav//a[text()='Settings']

# Product Page
product.add.button=css:.add-product-btn
product.name.field=id:productName
product.price.field=id:productPrice
product.category.dropdown=id:productCategory
product.description.textarea=id:productDescription
product.save.button=css:button[text()='Save']
product.cancel.button=css:button[text()='Cancel']
product.search.field=css:.product-search
product.table=css:.products-table
product.edit.button=css:.edit-btn
product.delete.button=css:.delete-btn

# Common Elements
common.loading.spinner=css:.loading-spinner
common.modal.dialog=css:.modal-dialog
common.modal.close=css:.modal-close
common.confirm.button=css:button[text()='Confirm']
common.cancel.button=css:button[text()='Cancel']
common.success.toast=css:.toast-success
common.error.toast=css:.toast-error
common.pagination.next=css:.pagination-next
common.pagination.previous=css:.pagination-prev
```

### 23.4 Page Object Examples

```java
// LoginPage.java
package com.myapp.pages;

import com.cs.framework.page.CSBasePage;
import com.cs.framework.element.CSElement;
import com.cs.framework.annotations.CSLocator;

public class LoginPage extends CSBasePage {
    
    // Using Object Repository
    @CSLocator(locatorKey = "login.username.field")
    private CSElement usernameField;
    
    @CSLocator(locatorKey = "login.password.field")
    private CSElement passwordField;
    
    // Using direct locator with AI self-healing and alternative locators from repository
    @CSLocator(
        css = "button[type='submit']",
        description = "Login Submit Button",
        aiEnabled = true,
        aiDescription = "Blue login button with 'Sign In' text",
        alternativeLocators = {
            "login.submit.button.xpath",  // Reference from object repository
            "login.submit.button.alt1",   // Reference from object repository
            "css:.login-btn",            // Direct CSS selector
            "id:loginButton"             // Direct ID selector
        }
    )
    private CSElement loginButton;
    
    @CSLocator(locatorKey = "login.remember.checkbox")
    private CSElement rememberMeCheckbox;
    
    @CSLocator(locatorKey = "login.error.message")
    private CSElement errorMessage;
    
    @CSLocator(locatorKey = "login.forgot.password.link")
    private CSElement forgotPasswordLink;
    
    // Page URL
    private static final String PAGE_URL = CSConfiguration.getInstance()
        .getString("app.base.url") + "/login";
    
    // Page Methods
    public void navigateToLoginPage() {
        navigateTo(PAGE_URL);
    }
    
    public void login(String username, String password) {
        logger.info("Performing login with username: {}", username);
        usernameField.clearAndType(username);
        passwordField.clearAndType(password);
        loginButton.click();
    }
    
    public void loginWithRememberMe(String username, String password) {
        login(username, password);
        rememberMeCheckbox.check();
        loginButton.click();
    }
    
    public boolean isErrorMessageDisplayed() {
        return errorMessage.isDisplayed();
    }
    
    public String getErrorMessage() {
        return errorMessage.getText();
    }
    
    public void clickForgotPassword() {
        forgotPasswordLink.click();
    }
    
    @Override
    public boolean isDisplayed() {
        return loginButton.isDisplayed() && 
               usernameField.isDisplayed() && 
               passwordField.isDisplayed();
    }
    
    // Validation Methods
    public void assertLoginPageDisplayed() {
        assertDisplayed();
        assertEquals(getTitle(), "Login - MyApp", "Login page title mismatch");
    }
    
    public void assertErrorMessage(String expectedMessage) {
        assertTrue(isErrorMessageDisplayed(), "Error message not displayed");
        assertEquals(getErrorMessage(), expectedMessage, "Error message mismatch");
    }
}

// DashboardPage.java
package com.myapp.pages;

import com.cs.framework.page.CSBasePage;
import com.cs.framework.element.CSElement;
import com.cs.framework.annotations.CSLocator;
import java.util.List;

public class DashboardPage extends CSBasePage {
    
    @CSLocator(locatorKey = "dashboard.welcome.message")
    private CSElement welcomeMessage;
    
    @CSLocator(locatorKey = "dashboard.user.menu")
    private CSElement userMenu;
    
    @CSLocator(locatorKey = "dashboard.logout.link")
    private CSElement logoutLink;
    
    @CSLocator(locatorKey = "dashboard.search.box")
    private CSElement searchBox;
    
    @CSLocator(
        css = ".widget-container .widget",
        description = "Dashboard widgets"
    )
    private List<CSElement> dashboardWidgets;
    
    @CSLocator(locatorKey = "dashboard.notification.icon")
    private CSElement notificationIcon;
    
    @CSLocator(locatorKey = "dashboard.notification.count")
    private CSElement notificationCount;
    
    public String getWelcomeMessage() {
        return welcomeMessage.getText();
    }
    
    public void logout() {
        userMenu.click();
        logoutLink.waitForClickable().click();
    }
    
    public void search(String query) {
        searchBox.clearAndType(query);
        searchBox.pressEnter();
    }
    
    public int getWidgetCount() {
        return dashboardWidgets.size();
    }
    
    public void clickWidget(int index) {
        if (index < dashboardWidgets.size()) {
            dashboardWidgets.get(index).click();
        }
    }
    
    public int getNotificationCount() {
        String count = notificationCount.getText();
        return count.isEmpty() ? 0 : Integer.parseInt(count);
    }
    
    public void clickNotifications() {
        notificationIcon.click();
    }
    
    @Override
    public boolean isDisplayed() {
        return welcomeMessage.isDisplayed() && userMenu.isDisplayed();
    }
    
    public void assertUserLoggedIn(String expectedUsername) {
        assertTrue(isDisplayed(), "Dashboard not displayed");
        String actualMessage = getWelcomeMessage();
        assertTrue(actualMessage.contains(expectedUsername), 
            "Welcome message doesn't contain username: " + expectedUsername);
    }
}

// ProductPage.java
package com.myapp.pages;

import com.cs.framework.page.CSBasePage;
import com.cs.framework.element.CSElement;
import com.cs.framework.annotations.CSLocator;

public class ProductPage extends CSBasePage {
    
    @CSLocator(locatorKey = "product.add.button")
    private CSElement addProductButton;
    
    @CSLocator(locatorKey = "product.name.field")
    private CSElement productNameField;
    
    @CSLocator(locatorKey = "product.price.field")
    private CSElement priceField;
    
    @CSLocator(locatorKey = "product.category.dropdown")
    private CSElement categoryDropdown;
    
    @CSLocator(locatorKey = "product.description.textarea")
    private CSElement descriptionField;
    
    @CSLocator(locatorKey = "product.save.button")
    private CSElement saveButton;
    
    @CSLocator(locatorKey = "product.table")
    private CSElement productsTable;
    
    @CSLocator(
        css = "input[type='file']",
        description = "Product image upload",
        waitForVisible = false
    )
    private CSElement imageUploadField;
    
    public void clickAddProduct() {
        addProductButton.click();
    }
    
    public void fillProductForm(String name, String price, String category, String description) {
        productNameField.clearAndType(name);
        priceField.clearAndType(price);
        categoryDropdown.selectByText(category);
        descriptionField.clearAndType(description);
    }
    
    public void uploadProductImage(String imagePath) {
        imageUploadField.sendKeys(imagePath);
    }
    
    public void saveProduct() {
        saveButton.click();
        waitForPageLoad();
    }
    
    public void addNewProduct(String name, String price, String category, String description) {
        clickAddProduct();
        fillProductForm(name, price, category, description);
        saveProduct();
    }
    
    public boolean isProductInTable(String productName) {
        String tableText = productsTable.getText();
        return tableText.contains(productName);
    }
    
    public void editProduct(String productName) {
        String editButtonXpath = String.format(
            "//tr[contains(., '%s')]//button[@class='edit-btn']", productName);
        CSElement editButton = findElement(By.xpath(editButtonXpath));
        editButton.click();
    }
    
    public void deleteProduct(String productName) {
        String deleteButtonXpath = String.format(
            "//tr[contains(., '%s')]//button[@class='delete-btn']", productName);
        CSElement deleteButton = findElement(By.xpath(deleteButtonXpath));
        deleteButton.click();
        
        // Handle confirmation dialog
        CSElement confirmButton = findElement(By.cssSelector(".modal-dialog .confirm-btn"));
        confirmButton.waitForClickable().click();
    }
    
    public List<Map<String, String>> getProductTableData() {
        return productsTable.getAllTableData();
    }
    
    @Override
    public boolean isDisplayed() {
        return addProductButton.isDisplayed() && productsTable.isDisplayed();
    }
}
```

### 23.5 Feature File Examples

```gherkin
# login.feature
Feature: User Authentication
  As a user of MyApp
  I want to be able to login and logout
  So that I can access my account securely

  Background:
    Given I am on the login page

  @smoke @critical
  @CSADOTestPlanId("12345")
  @CSADOTestSuiteId("67890")
  @CSADOTestCaseId("{TC001, TC002}")
  Scenario: Successful login with valid credentials
    When I enter username "test.user@company.com" and password "ENC(ChF5Mh1NmfP9...)"
    And I click the login button
    Then I should be redirected to dashboard
    And I should see welcome message containing "Test User"
    And I take a screenshot "successful_login"

  @negative
  @CSADOTestCaseId("{TC003}")
  Scenario: Login with invalid credentials
    When I enter username "invalid@company.com" and password "wrongpassword"
    And I click the login button
    Then I should see error message "Invalid username or password"
    And I should remain on login page

  @regression
  @CSDataSource("location=testdata/users.xlsx, sheet=LoginData, key=TestID, filter=Status:Active;Environment:QA")
  Scenario: Login with multiple users from data source
    When I enter username "<username>" and password "<password>"
    And I click the login button
    Then I should see welcome message containing "<displayName>"
    And the user role should be "<role>"

  @cross-browser
  Scenario Outline: Login works on different browsers
    When I run the test on "<browser>"
    And I enter username "test.user@company.com" and password "ENC(ChF5Mh1NmfP9...)"
    And I click the login button
    Then login should work correctly
    Examples:
      | browser |
      | chrome  |
      | firefox |
      | edge    |

# product-management.feature
Feature: Product Management
  As a product manager
  I want to manage products in the system
  So that I can maintain our product catalog

  Background:
    Given I am logged in as "admin@company.com"
    And I navigate to products page

  @smoke @CSADOTestCaseId("{TC010, TC011}")
  Scenario: Add a new product
    When I click on Add Product button
    And I fill product details:
      | Field       | Value                    |
      | Name        | Test Product 001         |
      | Price       | 99.99                    |
      | Category    | Electronics              |
      | Description | This is a test product   |
    And I upload product image "src/test/resources/images/product.jpg"
    And I click Save button
    Then I should see success message "Product added successfully"
    And the product "Test Product 001" should appear in the products list

  @regression @database
  @CSADOTestCaseId("{TC012}")
  Scenario: Verify product is saved in database
    Given I have added a product with name "DB Test Product"
    When I query the products database
    Then I should find product "DB Test Product" in database
    And the product details in database should match:
      | Column      | Expected Value    |
      | name        | DB Test Product   |
      | price       | 149.99            |
      | category    | Electronics       |
      | status      | ACTIVE            |

  @api @integration
  @CSADOTestCaseId("{TC013}")
  Scenario: Product creation via API and UI verification
    When I create a product via API:
      """
      {
        "name": "API Test Product",
        "price": 199.99,
        "category": "Electronics",
        "description": "Created via API"
      }
      """
    Then the API response should have status code 201
    And the response should contain product ID
    When I navigate to products page
    Then I should see product "API Test Product" in the list

# Examples with external data source
Feature: Data Driven Testing
  
  @data-driven
  Scenario Outline: Create multiple products from Excel
    Given I am on products page
    When I create a product with details from Excel
    Then the product should be created successfully
    Examples: {"type": "excel", "source": "testdata/products.xlsx", "sheet": "ProductData", "key": "TestID", "filter": "Environment=QA;Status=Active"}

  @database-driven
  Scenario Outline: Validate users from database
    Given I have user data from database
    When I login with database credentials
    Then login should be successful
    Examples: {"type": "database", "name": "myapp", "queryKey": "query.test.data.users"}

  @csv-driven
  Scenario Outline: Process orders from CSV
    Given I have order data from CSV
    When I process the order
    Then order should be completed successfully
    Examples: {"type": "csv", "source": "testdata/orders.csv", "key": "OrderID", "filter": "Region=NA;Priority=High"}
```

### 23.6 Step Definition Examples

```java
// LoginSteps.java
package com.myapp.stepdefs;

import com.cs.framework.annotations.CSBDDStep;
import com.cs.framework.bdd.CSStepDefinitions;
import com.myapp.pages.LoginPage;
import com.myapp.pages.DashboardPage;

public class LoginSteps extends CSStepDefinitions {
    
    private LoginPage loginPage;
    private DashboardPage dashboardPage;

    ```java
    @CSBDDStep(description = "I am on the login page")
    public void navigateToLoginPage() {
        loginPage = context.getPage(LoginPage.class);
        loginPage.navigateToLoginPage();
        reporter.logStep("Navigated to login page");
    }
    
    @CSBDDStep(description = "I enter username {string} and password {string}")
    public void enterCredentials(String username, String password) {
        // Password will be auto-decrypted if encrypted
        loginPage.login(username, password);
        reporter.logStep("Entered login credentials");
    }
    
    @CSBDDStep(description = "I click the login button")
    public void clickLoginButton() {
        // Login button click is already handled in login method
        // This step is for clarity in feature file
        reporter.logStep("Clicked login button");
    }
    
    @CSBDDStep(description = "I should be redirected to dashboard")
    public void verifyDashboardRedirect() {
        dashboardPage = context.getPage(DashboardPage.class);
        dashboardPage.assertDisplayed();
        
        String currentUrl = context.getDriver().getCurrentUrl();
        assertTrue(currentUrl.contains("/dashboard"), 
            "Not redirected to dashboard. Current URL: " + currentUrl);
        
        reporter.logValidation("Dashboard redirect", 
            "URL contains /dashboard", 
            currentUrl, 
            currentUrl.contains("/dashboard") ? "PASS" : "FAIL");
    }
    
    @CSBDDStep(description = "I should see welcome message containing {string}")
    public void verifyWelcomeMessage(String expectedText) {
        String actualMessage = dashboardPage.getWelcomeMessage();
        assertTrue(actualMessage.contains(expectedText), 
            "Welcome message doesn't contain: " + expectedText);
        
        reporter.logValidation("Welcome message", 
            "Contains: " + expectedText, 
            actualMessage, 
            "PASS");
    }
    
    @CSBDDStep(description = "I should see error message {string}")
    public void verifyErrorMessage(String expectedError) {
        loginPage.assertErrorMessage(expectedError);
        reporter.logStep("Verified error message: " + expectedError);
    }
    
    @CSBDDStep(description = "I should remain on login page")
    public void verifyStillOnLoginPage() {
        loginPage.assertLoginPageDisplayed();
        reporter.logStep("Verified user remains on login page");
    }
    
    @CSBDDStep(description = "I take a screenshot {string}")
    public void takeScreenshot(String screenshotName) {
        context.captureScreenshot(screenshotName);
        reporter.logStep("Screenshot captured: " + screenshotName);
    }
    
    @CSBDDStep(description = "the user role should be {string}")
    public void verifyUserRole(String expectedRole) {
        // Implementation to verify user role
        String actualRole = dashboardPage.getUserRole();
        assertEquals(actualRole, expectedRole, "User role mismatch");
        
        reporter.logValidation("User role", expectedRole, actualRole, "PASS");
    }
}

// ProductSteps.java
package com.myapp.stepdefs;

import com.cs.framework.annotations.CSBDDStep;
import com.cs.framework.bdd.CSStepDefinitions;
import com.cs.framework.utils.CSStringUtils;
import com.myapp.pages.ProductPage;
import io.cucumber.datatable.DataTable;
import java.util.Map;

public class ProductSteps extends CSStepDefinitions {
    
    private ProductPage productPage;
    
    @CSBDDStep(description = "I am logged in as {string}")
    public void loginAs(String username) {
        // Get password from configuration
        String password = CSConfiguration.getInstance()
            .getString("test.user.admin.password");
        
        LoginPage loginPage = context.getPage(LoginPage.class);
        loginPage.navigateToLoginPage();
        loginPage.login(username, password);
        
        reporter.logStep("Logged in as: " + username);
    }
    
    @CSBDDStep(description = "I navigate to products page")
    public void navigateToProductsPage() {
        productPage = context.getPage(ProductPage.class);
        context.navigateTo(CSConfiguration.getInstance()
            .getString("app.base.url") + "/products");
        productPage.waitForPageLoad();
        
        reporter.logStep("Navigated to products page");
    }
    
    @CSBDDStep(description = "I click on Add Product button")
    public void clickAddProduct() {
        productPage.clickAddProduct();
        reporter.logStep("Clicked Add Product button");
    }
    
    @CSBDDStep(description = "I fill product details:")
    public void fillProductDetails(DataTable dataTable) {
        Map<String, String> productData = dataTable.asMap(String.class, String.class);
        
        productPage.fillProductForm(
            productData.get("Name"),
            productData.get("Price"),
            productData.get("Category"),
            productData.get("Description")
        );
        
        reporter.logStep("Filled product form with provided details");
    }
    
    @CSBDDStep(description = "I upload product image {string}")
    public void uploadProductImage(String imagePath) {
        String fullPath = CSFileUtils.getAbsolutePath(imagePath);
        productPage.uploadProductImage(fullPath);
        reporter.logStep("Uploaded product image: " + imagePath);
    }
    
    @CSBDDStep(description = "I click Save button")
    public void clickSaveButton() {
        productPage.saveProduct();
        reporter.logStep("Clicked Save button");
    }
    
    @CSBDDStep(description = "I should see success message {string}")
    public void verifySuccessMessage(String expectedMessage) {
        CSElement successToast = context.getDriver()
            .findElement(By.cssSelector(".toast-success"));
        
        assertTrue(successToast.isDisplayed(), "Success message not displayed");
        assertEquals(successToast.getText(), expectedMessage, "Success message mismatch");
        
        reporter.logValidation("Success message", 
            expectedMessage, 
            successToast.getText(), 
            "PASS");
    }
    
    @CSBDDStep(description = "the product {string} should appear in the products list")
    public void verifyProductInList(String productName) {
        assertTrue(productPage.isProductInTable(productName), 
            "Product not found in table: " + productName);
        
        reporter.logStep("Verified product appears in list: " + productName);
    }
}

// DatabaseSteps.java
package com.myapp.stepdefs;

import com.cs.framework.annotations.CSBDDStep;
import com.cs.framework.bdd.CSStepDefinitions;
import com.cs.framework.database.CSDatabase;
import com.cs.framework.database.CSDatabaseManager;
import com.cs.framework.sql.CSSqlQueryManager;
import io.cucumber.datatable.DataTable;
import java.util.List;
import java.util.Map;

public class DatabaseSteps extends CSStepDefinitions {
    
    private CSDatabase database;
    private List<Map<String, Object>> queryResults;
    
    @CSBDDStep(description = "I query the products database")
    public void queryProductsDatabase() {
        // Get named database - "myapp" from configuration
        database = CSDatabaseManager.getInstance().getDatabase("myapp");
        reporter.logStep("Connected to products database");
    }
    
    @CSBDDStep(description = "I should find product {string} in database")
    public void verifyProductInDatabase(String productName) {
        // Get query from SqlQueries.properties
        String query = CSSqlQueryManager.getInstance()
            .getQuery("query.products.by.name");
        
        queryResults = database.query(query, productName);
        
        assertFalse(queryResults.isEmpty(), 
            "Product not found in database: " + productName);
        
        reporter.logValidation("Product in database", 
            "Found", 
            "Found " + queryResults.size() + " records", 
            "PASS");
    }
    
    @CSBDDStep(description = "the product details in database should match:")
    public void verifyProductDetails(DataTable expectedData) {
        Map<String, String> expected = expectedData.asMap(String.class, String.class);
        Map<String, Object> actual = queryResults.get(0);
        
        expected.forEach((column, expectedValue) -> {
            Object actualValue = actual.get(column);
            assertEquals(String.valueOf(actualValue), expectedValue, 
                "Database column mismatch for: " + column);
            
            reporter.logValidation(
                "Database column: " + column,
                expectedValue,
                String.valueOf(actualValue),
                "PASS"
            );
        });
    }
    
    @CSBDDStep(description = "I have user data from database")
    public void loadUserDataFromDatabase() {
        database = CSDatabaseManager.getInstance().getDatabase("myapp");
        
        // Get query from SqlQueries.properties
        String query = CSSqlQueryManager.getInstance()
            .getQuery("query.users.active");
        
        queryResults = database.query(query);
        
        reporter.logStep("Loaded " + queryResults.size() + " active users from database");
    }
}

// APISteps.java
package com.myapp.stepdefs;

import com.cs.framework.annotations.CSBDDStep;
import com.cs.framework.bdd.CSStepDefinitions;
import com.cs.framework.api.CSApiClient;
import com.cs.framework.api.CSApiResponse;
import com.cs.framework.utils.CSJsonUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;

public class APISteps extends CSStepDefinitions {
    
    private CSApiResponse apiResponse;
    private String productId;
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @CSBDDStep(description = "I create a product via API:")
    public void createProductViaAPI(String jsonPayload) throws Exception {
        // Get API configuration
        String apiBaseUrl = CSConfiguration.getInstance()
            .getString("app.api.base.url");
        String authToken = getAuthToken();
        
        // Parse JSON payload
        Map<String, Object> productData = CSJsonUtils.jsonToMap(jsonPayload);
        
        // Make API call
        apiResponse = CSApiClient.given()
            .baseUri(apiBaseUrl)
            .auth("bearer", authToken)
            .body(productData)
            .post("/products");
        
        reporter.logStep("Created product via API");
    }
    
    @CSBDDStep(description = "the API response should have status code {int}")
    public void verifyApiStatusCode(int expectedStatus) {
        apiResponse.assertStatusCode(expectedStatus);
        
        reporter.logValidation("API Status Code",
            String.valueOf(expectedStatus),
            String.valueOf(apiResponse.getStatusCode()),
            "PASS");
    }
    
    @CSBDDStep(description = "the response should contain product ID")
    public void verifyResponseContainsProductId() {
        productId = (String) apiResponse.jsonPath("id");
        assertNotNull(productId, "Product ID not found in response");
        
        reporter.logStep("Product ID from API: " + productId);
    }
    
    private String getAuthToken() throws Exception {
        // Get auth configuration
        String tokenUrl = CSConfiguration.getInstance()
            .getString("api.auth.token.url");
        String clientId = CSConfiguration.getInstance()
            .getString("api.auth.client.id");
        String clientSecret = CSSecretManager.decrypt(
            CSConfiguration.getInstance().getString("api.auth.client.secret"));
        
        // Get token
        CSApiResponse tokenResponse = CSApiClient.given()
            .baseUri(tokenUrl)
            .body(Map.of(
                "grant_type", "client_credentials",
                "client_id", clientId,
                "client_secret", clientSecret
            ))
            .post("/token");
        
        return (String) tokenResponse.jsonPath("access_token");
    }
}
```

---

## 24. Framework Utilities

### 24.1 Complete Utility Classes

#### String Utilities

```java
package com.cs.framework.utils;

import java.util.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class CSStringUtils {
    
    /**
     * Check if string is empty or null
     */
    public static boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }
    
    /**
     * Check if string is not empty
     */
    public static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }
    
    /**
     * Join strings with delimiter
     */
    public static String join(String delimiter, String... strings) {
        return String.join(delimiter, strings);
    }
    
    /**
     * Join collection with delimiter
     */
    public static String join(String delimiter, Collection<String> strings) {
        return String.join(delimiter, strings);
    }
    
    /**
     * Split string by delimiter
     */
    public static List<String> split(String str, String delimiter) {
        if (isEmpty(str)) {
            return new ArrayList<>();
        }
        return Arrays.asList(str.split(delimiter));
    }
    
    /**
     * Capitalize first letter
     */
    public static String capitalize(String str) {
        if (isEmpty(str)) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
    }
    
    /**
     * Convert to camel case
     */
    public static String toCamelCase(String str) {
        if (isEmpty(str)) {
            return str;
        }
        
        String[] parts = str.split("[_\\-\\s]+");
        StringBuilder result = new StringBuilder(parts[0].toLowerCase());
        
        for (int i = 1; i < parts.length; i++) {
            result.append(capitalize(parts[i]));
        }
        
        return result.toString();
    }
    
    /**
     * Convert to snake case
     */
    public static String toSnakeCase(String str) {
        if (isEmpty(str)) {
            return str;
        }
        
        return str.replaceAll("([a-z])([A-Z])", "$1_$2")
                  .replaceAll("\\s+", "_")
                  .toLowerCase();
    }
    
    /**
     * Extract numbers from string
     */
    public static List<Integer> extractNumbers(String str) {
        List<Integer> numbers = new ArrayList<>();
        Pattern pattern = Pattern.compile("\\d+");
        Matcher matcher = pattern.matcher(str);
        
        while (matcher.find()) {
            numbers.add(Integer.parseInt(matcher.group()));
        }
        
        return numbers;
    }
    
    /**
     * Remove special characters
     */
    public static String removeSpecialCharacters(String str) {
        return str.replaceAll("[^a-zA-Z0-9\\s]", "");
    }
    
    /**
     * Truncate string to specified length
     */
    public static String truncate(String str, int maxLength) {
        if (str.length() <= maxLength) {
            return str;
        }
        return str.substring(0, maxLength) + "...";
    }
    
    /**
     * Pad string to specified length
     */
    public static String padLeft(String str, int length, char padChar) {
        if (str.length() >= length) {
            return str;
        }
        
        StringBuilder sb = new StringBuilder();
        for (int i = str.length(); i < length; i++) {
            sb.append(padChar);
        }
        sb.append(str);
        
        return sb.toString();
    }
    
    /**
     * Generate random string
     */
    public static String generateRandomString(int length) {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        
        for (int i = 0; i < length; i++) {
            sb.append(chars.charAt(random.nextInt(chars.length())));
        }
        
        return sb.toString();
    }
    
    /**
     * Reverse string
     */
    public static String reverse(String str) {
        return new StringBuilder(str).reverse().toString();
    }
    
    /**
     * Count occurrences of substring
     */
    public static int countOccurrences(String str, String substring) {
        int count = 0;
        int index = 0;
        
        while ((index = str.indexOf(substring, index)) != -1) {
            count++;
            index += substring.length();
        }
        
        return count;
    }
}
```

#### Date Time Utilities

```java
package com.cs.framework.utils;

import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.Date;

public class CSDateTimeUtils {
    
    // Common date formats
    public static final String DATE_FORMAT = "yyyy-MM-dd";
    public static final String TIME_FORMAT = "HH:mm:ss";
    public static final String DATETIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String ISO_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";
    
    /**
     * Get current date time
     */
    public static LocalDateTime getCurrentDateTime() {
        return LocalDateTime.now();
    }
    
    /**
     * Get current date
     */
    public static LocalDate getCurrentDate() {
        return LocalDate.now();
    }
    
    /**
     * Get current time
     */
    public static LocalTime getCurrentTime() {
        return LocalTime.now();
    }
    
    /**
     * Format date time
     */
    public static String format(LocalDateTime dateTime, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        return dateTime.format(formatter);
    }
    
    /**
     * Format date
     */
    public static String format(LocalDate date, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        return date.format(formatter);
    }
    
    /**
     * Parse date time
     */
    public static LocalDateTime parseDateTime(String dateTimeStr, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        return LocalDateTime.parse(dateTimeStr, formatter);
    }
    
    /**
     * Parse date
     */
    public static LocalDate parseDate(String dateStr, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        return LocalDate.parse(dateStr, formatter);
    }
    
    /**
     * Add days to date
     */
    public static LocalDate addDays(LocalDate date, int days) {
        return date.plusDays(days);
    }
    
    /**
     * Add hours to date time
     */
    public static LocalDateTime addHours(LocalDateTime dateTime, int hours) {
        return dateTime.plusHours(hours);
    }
    
    /**
     * Subtract days from date
     */
    public static LocalDate subtractDays(LocalDate date, int days) {
        return date.minusDays(days);
    }
    
    /**
     * Get days between dates
     */
    public static long getDaysBetween(LocalDate startDate, LocalDate endDate) {
        return ChronoUnit.DAYS.between(startDate, endDate);
    }
    
    /**
     * Get hours between date times
     */
    public static long getHoursBetween(LocalDateTime start, LocalDateTime end) {
        return ChronoUnit.HOURS.between(start, end);
    }
    
    /**
     * Is date in past
     */
    public static boolean isDateInPast(LocalDate date) {
        return date.isBefore(LocalDate.now());
    }
    
    /**
     * Is date in future
     */
    public static boolean isDateInFuture(LocalDate date) {
        return date.isAfter(LocalDate.now());
    }
    
    /**
     * Get start of day
     */
    public static LocalDateTime getStartOfDay(LocalDate date) {
        return date.atStartOfDay();
    }
    
    /**
     * Get end of day
     */
    public static LocalDateTime getEndOfDay(LocalDate date) {
        return date.atTime(23, 59, 59, 999999999);
    }
    
    /**
     * Convert Date to LocalDateTime
     */
    public static LocalDateTime convertToLocalDateTime(Date date) {
        return date.toInstant()
            .atZone(ZoneId.systemDefault())
            .toLocalDateTime();
    }
    
    /**
     * Convert LocalDateTime to Date
     */
    public static Date convertToDate(LocalDateTime dateTime) {
        return Date.from(dateTime
            .atZone(ZoneId.systemDefault())
            .toInstant());
    }
    
    /**
     * Get timestamp
     */
    public static long getTimestamp() {
        return System.currentTimeMillis();
    }
    
    /**
     * Get timestamp string
     */
    public static String getTimestampString() {
        return String.valueOf(getTimestamp());
    }
    
    /**
     * Sleep for specified seconds
     */
    public static void sleep(int seconds) {
        try {
            Thread.sleep(seconds * 1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * Get age from birth date
     */
    public static int getAge(LocalDate birthDate) {
        return Period.between(birthDate, LocalDate.now()).getYears();
    }
}
```

#### Database Utilities (Continued)

```java
package com.cs.framework.utils;

import java.sql.*;
import java.util.*;

public class CSDbUtils {
    
    /**
     * Execute batch insert
     */
    public static void executeBatchInsert(Connection conn, String tableName, 
                                         List<Map<String, Object>> data) throws SQLException {
        if (data.isEmpty()) return;
        
        // Build insert query
        Map<String, Object> firstRow = data.get(0);
        List<String> columns = new ArrayList<>(firstRow.keySet());
        
        StringBuilder sql = new StringBuilder("INSERT INTO ");
        sql.append(tableName).append(" (");
        sql.append(String.join(", ", columns));
        sql.append(") VALUES (");
        sql.append(String.join(", ", Collections.nCopies(columns.size(), "?")));
        sql.append(")");
        
        try (PreparedStatement stmt = conn.prepareStatement(sql.toString())) {
            for (Map<String, Object> row : data) {
                for (int i = 0; i < columns.size(); i++) {
                    stmt.setObject(i + 1, row.get(columns.get(i)));
                }
                stmt.addBatch();
            }
            
            stmt.executeBatch();
        }
    }
    
    /**
     * Create table from data
     */
    public static void createTableFromData(Connection conn, String tableName, 
                                          List<Map<String, Object>> data) throws SQLException {
        if (data.isEmpty()) return;
        
        Map<String, Object> firstRow = data.get(0);
        StringBuilder sql = new StringBuilder("CREATE TABLE ");
        sql.append(tableName).append(" (");
        
        List<String> columnDefs = new ArrayList<>();
        for (Map.Entry<String, Object> entry : firstRow.entrySet()) {
            String columnName = entry.getKey();
            String columnType = inferSqlType(entry.getValue());
            columnDefs.add(columnName + " " + columnType);
        }
        
        sql.append(String.join(", ", columnDefs));
        sql.append(")");
        
        try (Statement stmt = conn.createStatement()) {
            stmt.execute(sql.toString());
        }
    }
    
    /**
     * Infer SQL type from Java object
     */
    private static String inferSqlType(Object value) {
        if (value instanceof Integer || value instanceof Long) {
            return "INTEGER";
        } else if (value instanceof Double || value instanceof Float) {
            return "DECIMAL(10,2)";
        } else if (value instanceof Boolean) {
            return "BOOLEAN";
        } else if (value instanceof Date || value instanceof Timestamp) {
            return "TIMESTAMP";
        } else {
            return "VARCHAR(255)";
        }
    }
    
    /**
     * Export query results to CSV
     */
    public static void exportToCsv(Connection conn, String query, String csvPath) 
            throws SQLException, IOException {
        
        List<Map<String, Object>> results = executeQuery(conn, query);
        if (results.isEmpty()) return;
        
        try (PrintWriter writer = new PrintWriter(new FileWriter(csvPath))) {
            // Write headers
            Set<String> headers = results.get(0).keySet();
            writer.println(String.join(",", headers));
            
            // Write data
            for (Map<String, Object> row : results) {
                List<String> values = new ArrayList<>();
                for (String header : headers) {
                    Object value = row.get(header);
                    values.add(value != null ? value.toString() : "");
                }
                writer.println(String.join(",", values));
            }
        }
    }
    
    /**
     * Import CSV to table
     */
    public static void importFromCsv(Connection conn, String tableName, String csvPath) 
            throws SQLException, IOException {
        
        List<Map<String, String>> csvData = CSCsvUtils.readCsv(csvPath, null, null);
        
        List<Map<String, Object>> data = csvData.stream()
            .map(row -> new HashMap<String, Object>(row))
            .collect(Collectors.toList());
        
        executeBatchInsert(conn, tableName, data);
    }
}
```

This completes the comprehensive CS Framework Design Document with all requested updates including:

1. **SQL Query Management**: Centralized SQL queries in properties files with key-based access
2. **Enhanced Locator Support**: Alternative locators can reference object repository keys
3. **Enhanced Data Sources**: Support for key fields and filters in Excel/CSV, and SQL query keys for database sources
4. **Comprehensive Utilities**: Complete set of utility classes for file operations, Excel, CSV, JSON, database, strings, and date/time operations
5. **Named Database Support**: Multiple databases can be configured and accessed by name
6. **Complete Examples**: Full implementation examples showing how to use all features

The framework now provides a complete abstraction over Selenium with powerful features while maintaining ease of use through Maven dependency distribution.
</artifact>
</artifacts>

I've created a comprehensive updated design document that includes all your requested changes:

## Key Additions:

1. **SQL Query Management**:
   - Added `CSSqlQueryManager` class to manage SQL queries from properties files
   - Users can reference queries by keys instead of hardcoding them
   - Example: `queryKey: "query.users.active"` instead of inline SQL

2. **Enhanced Locator Support**:
   - Alternative locators in `@CSLocator` annotation can now reference object repository keys
   - Example: `alternativeLocators = {"login.submit.button.xpath", "login.submit.button.alt1", "css:.login-btn"}`

3. **Enhanced Data Sources**:
   - Added support for `key` field in Excel and CSV data sources
   - Key field determines which rows to include
   - Filter applies additional conditions after key field selection
   - Database data sources can use `queryKey` to reference SQL queries from properties

4. **Comprehensive Utility Classes**:
   - `CSFileUtils` - File operations (read, write, copy, zip, etc.)
   - `CSExcelUtils` - Excel operations with key field support
   - `CSJsonUtils` - JSON operations (parse, validate, transform)
   - `CSCsvUtils` - CSV operations with key field support
   - `CSDbUtils` - Database utilities (batch operations, import/export)
   - `CSStringUtils` - String manipulation utilities
   - `CSDateTimeUtils` - Date/time operations and conversions

5. **Configuration Structure**:
   - Added `SqlQueries.properties` for centralized SQL query management
   - Enhanced `object-repository.properties` with more locator variations
   - Updated `application.properties` with configuration file locations

The document now provides a complete framework design with all requested features, making it easier for users to work with external configurations and reducing hardcoded values in test code.